\subsection{Définition}

Une automate non-déterministe fini est une variété d'automate similaire aux ADF, moyennant quelques modifications. Un automate non-déterministe fini s'écrit également:
	$$
	A=(Q,\Sigma, \delta, q_0, F)
	$$
mais avec :
\begin{itemize}
	\item $Q$ un ensemble fini d'états
	\item $\Sigma$ un alphabet
	\item $q_0$ l'état initial
	\item $F\subseteq Q$ l'ensemble des états acceptants
	\item $\delta : Q \times \Sigma \cup \{\epsilon\} \rightarrow 2^Q$ où $2^Q$ est \emph{l'ensemble des parties} de $Q$. Cela signifie qui la fonction $\delta$ retourne un ensemble d'états de $Q$
\end{itemize}

Dans la littérature \cite{??} les automates non-déterministes finis sont divisés en deux groupes :
\begin{enumerate}
	\item Ceux pour lequel au moins une transition de $\delta$ est définie pour $\epsilon$.
	\item Ceux pour lequel aucune transition n'est définie pour $\epsilon$. En pratique, la définition de delta devient $\delta : Q \times \Sigma \rightarrow 2^Q$.
\end{enumerate}
N'étant pas le sujet de ce document, ces deux ne reçoivent aucune distinction et sont tous deux notés ANF pour automate non-déterministe fini. Une transition sur $\epsilon$ est susceptible d'être définie pour tout ANF. 



\begin{exemple}\label{ex:anf}
	 De la même façon que pour l'exemple \ref{ex:adf} de la section \ref{sub:dfa}, considérons un automate \automaton défini comme suit :
	
\begin{itemize}
	\item $Q=\{q_0,q_1,q_2\}$
	\item $\Sigma=\{a,b,c\}$
	\item $q_0$ est l'état du même nom
	\item $\delta$ est donnée par la table \ref{fig:eanfdelta}. 
	\item $F=\{q_2\}$
\end{itemize}

$A$ est un ANF ; une colonne supplémentaire sert à représenter la transition sur $\epsilon$.
	
\begin{figure}[H]
	\centering
	\begin{tabular}{|r||c|c|c|c|}
		\hline
		&$\epsilon$&a&b&c\\
		\hline\hline
		$\rightarrow q_0$&$\{q_1,q_2\}$&$\emptyset$&$\{q_1\}$&$\{q_2\}$\\\hline
		$q_1$&$\emptyset$&$\{q_0\}$&$\{q_2\}$&$\{q_0,q_1\}$\\\hline
		$q_2^*$&$\emptyset$&$\emptyset$&$\emptyset$&$\emptyset$\\\hline
	\end{tabular}
	\caption{$\delta$}
	\label{fig:eanfdelta}
\end{figure}

De plus, $A$ peut être représenté par un graphe suivant la même méthodologie que dans la sous-section \ref{ss:grapheadf} pour les ADF. Additionnellement, $\epsilon$ peut servir d'étiquette même s'il n'appartient pas à $\Sigma$.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm, semithick, bend angle=10]
	
	\tikzstyle{every state}=[circle]
	
	\node[initial,state] (A)                    {$q_0$};
	\node[state]         (B) [above right of=A] {$q_1$};
	\node[accepting, state]         (C) [below right of=A] {$q_2$};
	
	\path 	
	(A) edge [bend left] node{$\epsilon$,b} (B)
	(A) edge node{$\epsilon$,c} (C)
	(B) edge [bend left] node{a,c} (A)	
	(B) edge [loop right] node{c} (B)
	(B) edge node{b} (C);
	\end{tikzpicture}
	\caption{Automate $A$}\label{fig:eanf}
\end{figure}
\end{exemple}

\subsection{Fermeture sur $\epsilon$}

Pour chaque état $q$ d'un ANF, un ensemble d'états peut être atteint sans lire de symbole. Il s'agit de l'état en question et de tous ceux pouvant être atteint uniquement par des transitions sur $\epsilon$. Cet ensemble s'appelle la \emph{fermeture sur epsilon} : ECLOSE($q$). Il peut être construit récursivement.

Soit un automate \automaton. Soit $q$ un état dans $Q$.

\paragraph{Cas de base} $q$ est dans ECLOSE($q$)

\paragraph{Pas de récurrence} Si $p$ est dans ECLOSE($q$) et qu'il existe un état $r$ tel quel $r\in\delta(p,\epsilon)$, alors $r$ est dans ECLOSE($q$)

\begin{exemple}\label{ex:anfclosure} Considérons l'automate $A$ de l'exemple \ref{ex:anf}. Les différentes fermetures peuvent être calculées :
	\begin{itemize}
		\item ECLOSE($q_0$) = $\{q_0,q_1,q_2\}$. En effet, $q_0$ appartient à sa fermeture, selon le cas de base. Aussi, $q_1,q_2\in\delta(q_0, \epsilon)$
		\item ECLOSE($q_1$)=$\{q_1\}$ par le cas de base.
		\item ECLOSE($q_2$)=$\{q_2\}$ par le cas de base.
	\end{itemize}
\end{exemple}


\subsection{Chemin}

La notion de fermeture permet de faciliter l'expression d'une fonction de transition étendue pour un ANF, ce qui permet d'exprimer des chemins et donc le langage.

Soit un ANF \automaton. La fonction de transition étendue $\hdelta$ retourne un ensemble d'états atteints par la lecture d'un mot depuis un état : $\hdelta(q,w)$ est un ensemble d'états atteignables par un chemin formant le mot $w$, avec éventuellement des transitions sur $\epsilon$.

$\hdelta$ vaut, de façon récursive sur le mot $w$ pour un état $q$:

\paragraph{Cas de base} $\hdelta(q,\epsilon)$=ECLOSE($q$). ECLOSE permet de calculer l'ensemble des états atteints uniquement par des transitions sur $\epsilon$, ce qui correspond à ce cas de base

\paragraph{Pas de récurrence} Supposons que $w=xa$. $a$ est le dernier symbole de $w$ et $\hdelta(q,x)$ est défini par récurrence. Alors, pour obtenir $\hdelta(q,w)$ :
\begin{enumerate}
	\item Posons $\{p_1,p_2,\dots, p_k\}=\hdelta(q,x)$. Ce sont les états atteints par la lecture de $x$, certains ont potentiellement été atteints par des transitions sur $\epsilon$.
	\item Posons $\{r_1,r_2,\dots, r_m\} = \bigcup_{i=1}^k\delta(p_i, a)$. Ce sont les nouveaux états atteints par la lecture de $a$. Comme $\delta$ retourne un ensemble, l'union permet de regrouper les états en un seul ensemble.
	\item Finalement, $\hdelta(q,w)=\bigcup_{j=1}^m$ECLOSE($r_j$). Cette étape de fermeture permet d'ajouter les états décrivant la lecture de $w$ suivie de transition sur $\epsilon$, ce qui exprime toujours le mot $w$. 
\end{enumerate}


Le langage exprimé par un ANF \automaton est alors défini par :
$$
	L(A) = \{w \in \Sigma^*| \hdelta(q_0, w) \cap F \neq \emptyset\}
$$

\subsection{Transformation d'ANF à ADF}\label{ss:eanfadf}

Cette section présente une méthode permettant de créer un ADF à partir d'un ANF. 

Soit un ANF \automaton. Alors l'ADF équivalent
$$
D=(Q_D, \Sigma, \delta_D, q_D, F_D)
$$
est défini par :
\begin{itemize}
	\item $Q_D = \{S | S \subseteq Q \text{ et } S \text{ est \emph{fermé sur epsilon}}\}$. Concrètement, $Q_D$ est l'ensemble des partie des $Q$ fermées sur $\epsilon$. Cette fermeture s'écrit $S$=ECLOSE(S), ce qui signifie que chaque transition sur $\epsilon$ depuis un état de $S$ mène à un état également dans $S$. L'ensemble $\emptyset$ est fermé sur $\epsilon$.
	\item $q_D$=ECLOSE($q_0$). L'état initial de $D$ est l'ensemble des états dans la fermeture sur $\epsilon$ des états de $A$.
	\item $F_D= \{S|S \in Q_D \text{ et } S \cap F \neq \emptyset\}$ contient les ensembles dont au moins un état est acceptant pour $A$.
	\item $\delta_D(S,a)$ est construit, $\forall a \in \Sigma, \forall S \in Q_D$ par :
		\begin{enumerate}
			\item Soit $S=\{p_1, p_2,\dots,p_k\}$.
			\item Calculer $\bigcup_{i=1}^k\delta(p_i,a)$. Renommer cet ensemble en $\{r_1, r_2, \dots, r_m\}$.
			\item Alors $\delta_D(S,a)=\bigcup_{j=1}^m\text{ECLOSE(}r_j\text{)}$.
		\end{enumerate}
\end{itemize}


\begin{exemple} Considérons l'automate \automaton de l'exemple \ref{ex:anf} et les fermetures calculées dans l'exemple \ref{ex:anfclosure}.

Alors, l'automate $D=(Q_D, \Sigma, \delta_D, q_D, F_D)$ est donné par :

\begin{itemize}
	\item $Q_D=\{\emptyset, \{q_1\}, \{q_2\}, \{q_1,q_2\}, \{q_0,q_1,q_2\}\}$. Les ensembles $\{q_0,q_1\}$ et $\{q_0,q_2\}$ sont des sous-ensembles de $Q$ mais ne sont pas fermé sur $\epsilon$.
	\item $q_D=\{q_0,q_1,q_2\}=\text{ECLOSE(}q_0\text{)}$.
	\item $F_D=\{\{q_2\}, \{q_1,q_2\}, \{q_0,q_1,q_2\}\}$, les ensembles contenant $q_2$, étant acceptant de $A$.
	\item $\delta_D$ est exprimé sur le graphe de la figure \ref{fig:dndf}.
\end{itemize}
	

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=4cm, semithick, bend angle=10]
	
	\tikzstyle{every state}=[circle]
	
	\node[accepting, state]         	(B) 				   {$\{q_0\}$};
	\node[state]		 	(A) [above of=B] {$\emptyset$};
	\node[state] (C) [right of=B] {$\{q_1\}$};
	\node[state]         	(D) [below of=C] {$\{q_2\}$};
	\node[accepting,state]         	(E) [right of=C] {$\{q_0,q_1\}$};
	\node[accepting,state]         	(F) [above of=C] {$\{q_0,q_2\}$};
	\node[state]         	(G) [below right of=E] {$\{q_1,q_2\}$};
	\node[initial,accepting, state]  	(H) [above right of=E] {$\{q_0,q_1,q_2\}$};
	
	\path 
	(A) edge [loop left] node{a,b,c} (A)
	
	(B) edge  node{a} (A)
	(B) edge [bend left, near start] node{b} (C)
	(B) edge node{c} (D)
	
	(C) edge [bend left, near start] node{a} (B)
	(C) edge node{b} (D)
	(C) edge node{c} (E)
	
	(D) edge [near end,above right] node{a,b,c} (A)
	
	(E) edge [bend left=20,near start] node{a} (B)
	(E) edge [bend left] node{b} (G)
	(E) edge node{c} (H)
	
	(F) edge node{a,b} (A)
	(F) edge [bend left=20,near end] node{c} (D)
	
	(G) edge [bend left=80] node{a} (B)
	(G) edge node{b} (D)
	(G) edge [bend left] node{c} (E)
	
	(H) edge [bend right=20, near start] node{a} (B)
	(H) edge node{b} (G)
	(H) edge [loop above] node{c} (H)	
	;
	\end{tikzpicture}
	\caption{Automate $D$. De par la construction par les parties de $Q$, le nombre de parties est exprimé en exponentiel, d'où la complexité du graphe. Ici, $\{q_0,q_2\}$ n'est pas atteignable et peut être supprimé. De même $\emptyset$ est souvent omis pour clarifier la représentation.}\label{fig:dndf}
\end{figure}
\end{exemple}



\begin{theorem}\label{anf-dnf}
	Un langage $L$ peut être représenté par un ANF si et seulement si il peut l'être par un ADF.
\end{theorem}

\begin{proof}
	 Soit $L$ un langage. Cette preuve étant une double implication, chacune peut être prouvée séparément.
	
	($\Leftarrow$) $L$ peut être représenté par un ADF $\implies$ $L$ peut être représenté par un ANF. Supposons qu'un automate $D=(Q_D, \Sigma, \delta_D, q_D, F_D)$ représente $L$ : $L(D)=L$. 
	L'ANF \automaton correspondant est construit comme suit :
	
	\begin{itemize}
		\item $Q=\{\{q\}|q\in Q_D\}$
		\item $\delta$ contient les transitions de $D$ modifiées. Les objets retournés deviennent des ensembles d'états. C'est-à-dire, si $\delta_D(q,a)=p$ alors $\delta(q,a)=\{p\}$. De plus, pour chaque état $q\in Q_D$, $\delta(q,\epsilon)=\emptyset$. 
		\item $q_0=\{q_D\}$
		\item $F=\{\{q\}| q\in F_D\}$
	\end{itemize}
	 
	 Dès lors, les transitions sont les mêmes entre $D$ et $A$, mais $A$ précise explicitement qu'il n'y a pas de transition sur $\epsilon$. Comme $A$ représente le même langage, un ANF représente $L$.
	
	
	($\Rightarrow$) $L$ peut être représenté par un ANF $\implies$ $L$ peut être représenté par un ADF. Soit l'automate \automaton. Supposons qu'il représente $L$ ($L=L(A)$). Considérons l'automate obtenu par la transformation détaillée à la section précédente \ref{ss:eanfadf} :
	$$
	D=(Q_D, \Sigma, \delta_D, q_D, F_D)
	$$
	Montrons que $L(D)=L(A)$. Pour ce faire, montrons que les fonctions de transition étendues sont équivalentes. Auquel cas, les chemins sont équivalents et donc les langages également.
	Montrons que $\hdelta(q_0,w)=\hdelta_D(q_D,w)$ pour tout mot $w$, par récurrence sur $w$.
	
	\paragraph{Cas de base} Si $|w|=0$, $w=\epsilon$. $\hdelta(q_0,\epsilon)=$ ECLOSE($q$), par définition de la fonction de transition étendue. $q_D$=ECLOSE($q_0$) par la construction de $q_D$. Finalement, pour un ADF (ici, $D$), $\hdelta(p,\epsilon)=p$, pour tout état $p$. Par conséquent, $\hdelta_D(q_D,\epsilon)=q_D=\text{ECLOSE(}q_0\text{)}=\hdelta(q_0,\epsilon)$.
	
	\paragraph{Pas de récurrence} Supposons $w=xa$ avec $a$ le dernier symbole de $w$. Notre hypothèse de récurrence est que $\hdelta_D(q_D,x)=\hdelta(q_0,x)$. Ce sont bien les mêmes objets car $\hdelta_D$ retourne un état de $D$ qui correspond à un ensemble d'états de $A$. Notons celui-ci $\{p_1,p_2, \dots, p_k\}$. Par définition de $\hdelta$ pour un ANF, $\hdelta(q_0,w)$ est obtenu en :
	
	\begin{enumerate}
		\item Soit $\{r_1,r_2,\dots, r_m\}$ donné par $\bigcup_{i=1}^k \delta(p_i,a)$, les états obtenus par la lecture du symbole $a$ à partir de $\{p_1,p_2,\dots,p_k\}$.
		\item Alors $\hdelta(q_0,w)=\bigcup_{j=1}^m$ECLOSE($r_j$). Un état atteint par la lecture de $a$ l'est aussi par $a\epsilon$.
	\end{enumerate}
	
	$D$ a été construit avec ces deux mêmes étapes pour $\delta_D(\{p_1,p_2,\dots, p_k\},a)$. Dès lors, $\hdelta_D(q_D,w)=\delta_D(\{p_1,p_2,\dots, p_k\},a)=\bigcup_{j=1}^k$ECLOSE($p_j$)$=\hdelta(q_0,w)$. 
	
	On a bien $\hdelta_D(q_D,w)=\hdelta(q_0,w)$. Les langages sont équivalents.
	
\end{proof}

\begin{complexity}
	
	La complexité d'une conversion ANF vers ADF peut être exprimée en fonction de $n$ le nombre d'états de l'ANF. La taille de l'alphabet $\Sigma$ est ici comptée comme une constante, elle est ignorée dans l'analyse grand-O. L'algorithme de conversion se fait en deux étapes. Le calcul de ECLOSE et la construction à proprement parler.
	
	\begin{itemize}
		\item ECLOSE : Pour chacun des $n$ états, il y a au plus $n^2$ transitions à suivre sur $\epsilon$ pour construire la fermeture. Ceci représente le cas où tous les états sont reliés avec tous les autres par des transitions sur $\epsilon$. Le coût de cet algorithme est dès lors de $n*\mathcal{O}(n^2)=\mathcal{O}(n^3)$.
		
		\item Construction : Posons $s$ le nombre d'états dans l'ADF (qui, dans le pire des cas vaut $s=2^n$ par la construction des sous-ensembles). La création d'un état est en temps $\mathcal{O}(n)$, correspondant au plus à $n$ états de l'ANF. Pour ce qui est des transitions, pour chacun des $s$ nouveaux états, ECLOSE contient au plus $n$ éléments. Chacune des $n^2$ transitions de l'ADF sont alors suivies pour chaque symbole $a\in\Sigma$. Le coût de construction d'une transition est alors de $n*\mathcal{O}(n^2)=\mathcal{O}(n^3)$ auquel vient s'ajouter $\mathcal{O}(n^2)$, négligeable, pour l'union de l'ensemble obtenu.
	\end{itemize}
	
	La complexité totale est $\mathcal{O}(n^3) + s * \mathcal{O}(n^3) = \mathcal{O}(s*n^3) = \mathcal{O}(2^n*n^3)$.
	Le détail est donné sur $s$ car, comme mentionné par Hopcroft et Al. \cite{Hopcroft00}, en pratique le nombre de l'état dans l'ADF obtenu est rarement de l'ordre de $2^n$, typiquement de l'ordre de $n$.
	
\end{complexity}


\begin{complexity}
	La conversion d'un ADF \automaton vers un ANF consiste au remplacement d'états par des ensembles d'états. Si l'ADF contient $n$ états, cette étape est en $\mathcal{O}(n)$. De plus, une colonne pour $\epsilon$ doit être ajoutée à la table de transition (pour la fonction $\delta$), et ce pour chacun des états. Cette étape se fait également en $\mathcal{O}(n)$.
	
	La complexité totale d'une conversion d'un ADF vers un ANF est en $\mathcal{O}(n)$.
\end{complexity}
