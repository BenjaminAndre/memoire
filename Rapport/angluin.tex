L'algorithme d'Angluin est un algorithme d'apprentissage automatique d'automate. Il requiert un professeur pouvant vérifier :
\begin{itemize}
	\item L'équivalence entre deux automates.
	\item L'appartenance d'un mot à un automate.
\end{itemize}
Grâce à ce professeur, l'élève (ici joué par l'algorithme) peut apprendre un automate.

Celui-ci repose, en plus des éléments précédents, sur différents concepts expliqués dans les différentes sous-sections. Une fois toutes les bases posées, une exécution de l'algorithme d'Angluin sur un exemple est proposée en \ref{ss:a_exemple}, suivie du fonctionnement formel de l'algorithme et des preuves sur son exactitude et sa complexité. Cette section s'appuie principalement sur \cite{Neider14} en plus des notions précédentes.


% ██████  ██
% ██   ██ ██
% ██████  ██
% ██   ██ ██
% ██   ██ ███████

\subsection{La relation \rl}

Soit un langage $L$ sur un alphabet $\Sigma$.

Soit la relation $R_L\subseteq\Sigma^*\Sigma^*$. Deux mots $x$ et $y$ respectent la \emph{relation de Myhill-Nérode $R_L$} si

$$\forall z \in \Sigma^*, xz \in L \Leftrightarrow yz \in L$$

Intuitivement, deux mots sont en relation si pour tout mot qu'on leur concatène, les deux mots résultants sont tous deux dans le langage $L$ ou non.

\begin{lemma}
	Cette relation est une relation d'équivalence. De plus, elle est congruente à droite. C'est à dire que si $xR_Ly$, alors pour tout symbole $a \in \Sigma$, $xaR_Lya$
\end{lemma}

\begin{proof}[Equivalence et Congruence à droite]
	Dire d'une relation qu'elle décrit une équivalence, revient à dire qu'elle est réflexive, transitive et symétrique
\begin{itemize}
		\item $R_L$ est réflexive. Soit $x \in \Sigma^*$. Soit $z \in \Sigma^*$. Montrer que $xR_Lx$ est vrai revient à montrer que $ xz \in L \Leftrightarrow xz \in L$ est vrai. $R_L$ est donc réflexive.
		\item $R_L$ est symétrique. Soient $x, y \in \Sigma^*$ tels que $xR_Ly$. Soit $w \in \Sigma^*$. Montrer que $yR_Lx$ revient à montrer que $ yw \in L \Leftrightarrow xw \in L$. Or, par hypothèse, $ xz \in L \Leftrightarrow yz \in L$, qui peut s'écrire aussi $ yz \in L \Leftrightarrow xz \in L$ pour tout $z \in \Sigma^*$, et en particulier $z=w$.
		\item $R_L$ est transitive. Soient $x,y,u \in \Sigma^*$ tels que $xR_Ly$ et $yR_Lz$. Soit $w \in \Sigma^*$. Comme $ xz \in L \Leftrightarrow yz \in L$ et $ yz \in L \Leftrightarrow uz \in L$ pour tout $z \in \Sigma^*$ (par hypothèse), c'est vrai en particulier pour $z=w$. Dès lors,  $ xw \in L \Leftrightarrow yw \in L$ et $ yw \in L \Leftrightarrow uw \in L$. Par transitivité de l'implication, on obtient $ xw \in L \Leftrightarrow uw \in L$, à savoir $xR_Lu$.
		\item $R_L$ est congruente à droite. Soient $x,y \in \Sigma^*$ tels que $xR_Ly$. Soit $a \in \Sigma$. Par hypothèse, $ xz \in L \Leftrightarrow yz \in L$ pour tout $z \in \Sigma^*$. Cela doit donc être vrai en particulier pour le mot $z=aw$ avec $w$ quelconque. En remplaçant dans l'hypothèse, on obtient  $ xaw \in L \Leftrightarrow yaw \in L$. Ce qui montre que $xaR_Lya$.
	\end{itemize}

\hfill$\square$
\end{proof}

% ███    ██ ███████ ██████   ██████  ██████  ███████
% ████   ██ ██      ██   ██ ██    ██ ██   ██ ██
% ██ ██  ██ █████   ██████  ██    ██ ██   ██ █████
% ██  ██ ██ ██      ██   ██ ██    ██ ██   ██ ██
% ██   ████ ███████ ██   ██  ██████  ██████  ███████

\subsection{Théorème de Myhill-Nerode}

	Avant d'introduire la théorème de Myhill-Nérode, il faut s'intéresser à la relation d'équivalence \rb, qui facilite l'écriture de la preuve du théorème.

	\begin{definition}[Relation \rb]
		Soit un automate \automaton. Soient deux mots $x,y\in\Sigma^*$. Alors la relation $xR_By$ est vraie si et seulement si $\hdelta(q_0,x)=\hdelta(q_0,y)$.
	\end{definition}

	\begin{lemma}
		\rb est une relation d'équivalence congruente à droite.
	\end{lemma}

	\begin{proof}
		Prouver qu'une relation est dite d'équivalence, il faut prouver que celle-ci est transitive, réflexive et symétrique.
		Soit un automate \automaton.
		\paragraph{Transitivité} Soient $x,y,z\in\Sigma^*$. Supposons que $xR_By$ et $yR_Bz$. On a bien $\hdelta(q_0,x)=\hdelta(q_0,y)=\hdelta(q_0,z)$ par la transitivité de l'équivalence entre deux états.
		\paragraph{Réflexivité} Soit $y\in\Sigma^*$. On a bien $\hdelta(q_0,y)=\hdelta(q_0,y)$ par réflexiviré de l'équivalence sur un état.
		\paragraph{Symétrie} Soient $x,y\in\Sigma^*$. Supposons que $xR_By$. On a bien $\hdelta(q_0,y)=\hdelta(q_0,x)$ par symétrie de l'équivalence entre deux états.
		\paragraph{Congruence à droite} Soient $x,y\in\Sigma^*$ tels que $xR_By$. Soit $z\in\Sigma^*$. Montrons que $xzR_Byz$. $\hdelta(q_0,xz)=\hdelta(\hdelta(q_0,x),z)=\hdelta(\hdelta(q_0,y),z)=\hdelta(q_0,yz)$.
	\end{proof}

	\begin{theorem}
		Les trois énoncés suivants sont équivalents :
		\begin{enumerate}
			\item Un langage $L\subseteq\Sigma^*$ est accepté par un DFA.
			\item Il existe une congruence à droite sur $\Sigma^*$ d'index fini telle que $L$ est l'union de certaines classes d'équivalence.
			\item La relation d'équivalence $R_L$ est d'index fini.
		\end{enumerate}
	\end{theorem}


	\begin{proof}\label{proof:mn}
		La preuve d'équivalence se fait en prouvant chaque implication de façon cyclique :\\

		$(1)\rightarrow(2)$ Supposons que (1) soit vrai, c'est-à-dire que le langage $L$ est accepté par un automate déterministe \automaton. Considérons la relation d'équivalence congruente à droite \rb. Soit un mot $w\in\Sigma^*$. Alors tout mot $x\in\Sigma^*$ tel que $\hdelta(q_0,x)=\hdelta(q_0,w)$ appartient à la même classe d'équivalence $[w]$. Or, la fonction $\hdelta$ retourne un état $q\in Q$. Chaque classe d'équivalence sur $\Sigma$ correspond alors à un état de l'automate. Comme $Q$ est fini, \rb est d'index fini. De plus, un sous-ensemble des classes d'équivalences doit correspondre aux états acceptants $q\in F$. Alors, $L$ est l'union de ces classes d'équivalence.

		$(2)\rightarrow(3)$ Supposons qu'il existe une relation $E$ satisfaisant (2). Montrons que chaque classe de celle-ci est intégralement contenue dans une seule classe de \rl. Puisque $E$ est d'index fini, c'est un argument suffisant pour montrer que \rl est d'index fini. Soit $x,y$ tels que $xEy$. Comme $E$ est congruente à droite, pour tout mot $z \in \Sigma^*$, on sait que $xzEyz$. Comme $L$ est un union de ces classes d'équivalence, $xzEyz$ implique que $xz \in L \Leftrightarrow yz \in L$, ce qui revient à $xR_Ly$. Cela signifie que tout mot dans la classe d'équivalence de $x$ définie par $E$ se retrouve dans la même classe d'équivalence que $x$ cette fois définie par \rl. Ceci permet de conclure que chaque classe d'équivalence de $E$ est contenue dans une classe d'équivalence de \rl et donc que \rl est d'index fini.

		$(3)\rightarrow(1)$ Considérons la relation \rl définie précédemment. Soit un automate \automaton défini comme suit :
		\begin{itemize}
			\item Chaque état $q\in Q$ correspond à une classe d'équivalence de \rl.
			\item Comme \rl porte sur un langage, l'alphabet $\Sigma$ de celui-ci est déjà défini.
			\item Si $[[\epsilon]]$ est la classe d'équivalence de $\epsilon$ sur \rl, $q_0$ correspond à cette classe.
			\item Si $q$ représente $[[x]]$ et $q_1$ représente $[[xa]]$, alors $\delta(q,a)=q_1$. Cette définition est cohérente car \rl est congruente à droite.
			\item $F = \{[[x]]|x \in L\}$.
		\end{itemize}
		Cet automate est déterministe par la définition de $\delta$ et fini car $Q$ l'est, le nombre de classes de \rl étant fini par hypothèse. De plus, cet automate accepte tout mot $x\in L$ puisque $\delta(q_0,x)=[[x]]\in F$(par définition, puisque $x\in L$).
		\hfill$\square$
	\end{proof}


	\begin{corollary}
		La partie $(3)\rightarrow(1)$ de la preuve \ref{proof:mn} donne une méthode permettant de construire un ADF à partir des classes d'équivalences de la relation \rl.
	\end{corollary}

On peut prouver que l'automate obtenu de cette façon est l'automate minimal de $L$. Une preuve est disponible dans l'ouvrage \cite{Hopcroft79} en lien avec le théorème 3.10.


  % ████████  ██████
  %    ██    ██    ██
  %    ██    ██    ██
  %    ██    ██    ██
  %    ██     ██████

  \subsection{La table d'observation}

	%  ██████ ██       ██████   ██████  ██████  ██   ██
	% ██      ██      ██    ██ ██      ██    ██ ██   ██
	% ██      ██      ██    ██ ██      ██    ██ ███████
	% ██      ██      ██    ██ ██      ██    ██ ██   ██
	%  ██████ ███████  ██████   ██████  ██████  ██   ██

\subsection{Clôture et cohérence}

\subsubsection*{Clôture}
La propriété de \emph{clôture} s'exprime mathématiquement par

$$ \forall u \in R, \forall a \in \Sigma, \exists v \in R, ua R_O v$$

Cette propriété peut être vérifiée par cet algorithme, expliqué de façon visuelle sur la table O :

\begin{algorithm}[H]
	\begin{algorithmic}[1]
		\ENSURE si la clôture est respectée ou non

		\FORALL {élément $w$ de la section $R$}
		\FORALL {symbole $a$ dans $\Sigma$}
			\IF {$wa$ est dans $R$}
				\STATE continuer
			\ELSE
				\STATE \COMMENT{$wa$ est dans $R.\Sigma$ par construction}
				\IF {La ligne de $wa$ dans $T$ est différente de celle de $w$}
					\RETURN Faux
				\ENDIF
			\ENDIF
		\ENDFOR
		\ENDFOR
		\RETURN Vrai
	\end{algorithmic}
	\caption{Vérification de la clôture}\label{alg:cloture}
\end{algorithm}

\subsubsection*{Cohérence}

La propriété de \emph{cohérence} se définit mathématiquement comme

$$ \forall u,v \in R, u R_O v \Rightarrow \forall a \in \Sigma, ua R_O va$$

Concrètement, il s'agit de prendre deux mots ($u,v$) dans $R$ ayant la même ligne dans $T$ et vérifier, pour chaque symbole ($a$), s'ils ($ua,va$) ont la même ligne dans $T$.



%  █████  ██       ██████   ██████
% ██   ██ ██      ██       ██    ██
% ███████ ██      ██   ███ ██    ██
% ██   ██ ██      ██    ██ ██    ██
% ██   ██ ███████  ██████   ██████

\subsection{L'algorithme}\label{ss:a_exemple}
Considérons l'automate $A_3$ de la figure \ref{fig:a3} construit à la section \ref{ss:mini} sur la minimisation.

\todo{Marquer la différence entre $R_L$ et $R_O$}

\subsubsection{Première itération}

L'algorithme d'Angluin précise, pour son cas de base, une initialisation de la table $T$ avec les ensembles $R$ et $S$ contenant uniquement $\epsilon$. Le champ $R.\{a,b\}$ ($R.\Sigma$) est rempli via des requêtes d'appartenance sur les mots $a$ et $b$.

\begin{minipage}{0.5\linewidth}
	\centering
	\begin{tabular}{|c|c|}
		\hline
		$O_0$ & $\epsilon$\\
		\hline
		$\epsilon$ & 0\\
		\hline
		$a$ & 0\\
		$b$ & 0\\
		\hline
	\end{tabular}
\end{minipage}
\begin{minipage}{0.5\linewidth}
	\centering
	\begin{figure}[H]
		\centering
		\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm, semithick, bend angle=10]
		\tikzstyle{every state}=[circle]
		\node[initial, state] (A) {$[[\epsilon]]$};
		\path (A) edge [loop above] node {a,b} (A);
		\end{tikzpicture}
		\caption*{Automate $O_0$}
	\end{figure}
\end{minipage}


\vspace{1cm}
L'étape suivante consiste à vérifier la \emph{clôture} de la table d'observation $O_0$. Mathématiquement :

$$ \forall u \in R, \forall a \in \Sigma, \exists v \in R, ua R_L v$$

Intuitivement, pour chaque symbole (ici, $\{a,b\}$, et ce sera vrai jusqu'à la dernière itération), tout mot candidat (dans $R$, la partie supérieure de la table) doit se retrouver, complété de ce symbole, dans une classe d'équivalence d'un autre candidat de $R$. Ici, de toute évidence, les mots $a$ et $b$ sont dans la même classe d'équivalence que $\epsilon$. Dès lors, la propriété de clôture est respectée.

Si la clôture est respectée, alors la question de la cohérence se pose. Mathématiquement :

$$ \forall u,v \in R, u R_L v \Rightarrow \forall a \in \Sigma, ua R_L va$$

Intuitivement, si deux candidats semblent être dans la même classe d'équivalence (leur lignes dans la table supérieure sont identiques), alors pour n'importe quel symbole, les deux nouveaux mots sont également dans une même classe d'équivalence (leur lignes, potentiellement dans la partie inférieure de la table, sont identiques). N'ayant qu'un seul candidat, cette propriété est forcément respectée ($R_L$ est réflexive).

Les deux propriétés étant respectées, les classes d'équivalences sont calculées (trivialement ici), et un automate $O_0$ est proposé à l'enseignant pour vérification.

Sur cette itération, un automate initial a été proposé, et aucun état final ne pouvant être atteint avec un seul symbole, la version est minime.

\subsubsection{Seconde itération}

L'enseignant répond que non, les automates ne sont pas équivalents. Il fourni le contre-exemple $ba$. Comme il est rejeté par $O_0$, cela signifie qu'il est accepté par $A_3$. Une nouvelle table est alors construite, en ajoutant $ba$ et ses préfixes (ici, juste $b$) à $R$. $R.\Sigma$ est calculé et les mots n'ayant pas encore reçu une valeur dans $T$ sont soumis à l'enseignant pour un test d'appartenance.
Les valeurs ajoutées ou modifiées dans la table d'observation sont mises en évidence \textcolor{red}{en rouge}.
\vspace{1cm}

\begin{minipage}{0.25\linewidth}
	\centering
	\begin{tabular}{|c|c|}
		\hline
		$O_1$ & $\epsilon$\\
		\hline
		$\epsilon$ & 0\\
		\textcolor{red}{$b$} & \textcolor{red}{0}\\
		\textcolor{red}{$ba$} & \textcolor{red}{1}\\
		\hline
		$a$ & 0\\
		\textcolor{red}{$bb$} & \textcolor{red}{0}\\
		\textcolor{red}{$baa$} & \textcolor{red}{1}\\
		\textcolor{red}{$bab$} & \textcolor{red}{1}\\
		\hline
	\end{tabular}
\end{minipage}
\begin{minipage}{0.25\linewidth}
	\centering
	\begin{tabular}{|c|cc|}
		\hline
		$O_2$ & $\epsilon$ & \textcolor{red}{$a$}\\
		\hline
		$\epsilon$ & 0& \textcolor{red}{0}\\
		$b$ & 0&\textcolor{red}{1}\\
		$ba$ & 1&\textcolor{red}{1}\\
		\hline
		$a$ & 0&\textcolor{red}{0}\\
		$bb$ & 0&\textcolor{red}{1}\\
		$baa$ & 1&\textcolor{red}{1}\\
		$bab$ & 1&\textcolor{red}{1}\\
		\hline
	\end{tabular}
\end{minipage}
\begin{minipage}{0.5\linewidth}
	\centering
	\begin{figure}[H]
		\centering
		\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm, semithick, bend angle=10]
		\tikzstyle{every state}=[circle]

		\node[initial, state] (A) {$[[\epsilon]]$};
		\node[state] (B) [right of=A] {$[[b]]$};
		\node[accepting, state] [right of=B] (C) {$[[ba]]$};

		\path
		(A) edge [loop above] node {a} (A)
		(A) edge node {b} (B)
		(B) edge node {a} (C)
		(B) edge [loop above] node {b} (B)
		(C) edge [loop above] node {a,b} (C);


		\end{tikzpicture}
		\caption*{Automate $O_2$}
	\end{figure}
\end{minipage}

\vspace{1cm}
Comme pour la première itération, la clôture est testée, suivie de la \emph{cohérence}. Celle-ci n'est pas respectée : si on considère les mots $\epsilon$ et $b$, qui ont la même ligne dans la table $T$ ($\epsilon R_O b$), le symbole $a$, on obtient les mots $a$ et $ba$ qui n'ont pas la même ligne : ($\neg a R_O ba$). Le symbole $a$ est alors ajouté à $S$ et une nouvelle table $O_2$ est calculée.

La clôture étant déjà vérifiée, la question de la cohérence est reposée, et cette fois-ci elle est vérifiée ; l'automate est construit et proposé à l'enseignant.

Sur cette itération, l'algorithme a reçu le mot $ba$ comme étant accepté. Il a du ajouter $a$ à $S$ pour permettre de différencier certains états. L'automate se voit ajouter les états $[[b]]$ et $[[ba]]$.

\subsubsection{Troisième itération}

Suivant toujours l'algorithme de comparaison d'automates détaillé dans la section \ref{sec:algorithmes}, l'enseignant découvre qu'ils sont différents.

Il sort le contre-exemple $aaba$. Si c'est un contre-exemple et qu'il est accepté par $O_2$, c'est qu'il ne l'est pas (0) par $A_4$. Une nouvelle table $O_3$ doit être construite.

\begin{minipage}{0.25\linewidth}
	\centering
	\begin{tabular}{|c|cc|}
		\hline
		$O_3$ & $\epsilon$ & $a$\\
		\hline
		$\epsilon$ & 0 &0\\
		\textcolor{red}{$a$}&\textcolor{red}{0}&\textcolor{red}{0}\\
		$b$&0&1\\
		\textcolor{red}{$aa$}&\textcolor{red}{0}&\textcolor{red}{0}\\
		$ba$&1&1\\
		\textcolor{red}{$aab$}&\textcolor{red}{0}&\textcolor{red}{0}\\
		\textcolor{red}{$aaba$}&\textcolor{red}{0}&\textcolor{red}{0}\\
		\hline
		\textcolor{red}{$ab$}&\textcolor{red}{0}&\textcolor{red}{1}\\
		$bb$&0&1\\
		\textcolor{red}{$aaa$}&\textcolor{red}{0}&\textcolor{red}{0}\\
		$baa$&1&1\\
		$bab$&1&1\\
		\textcolor{red}{$aabb$}&\textcolor{red}{0}&\textcolor{red}{0}\\
		\textcolor{red}{$aabaa$}&\textcolor{red}{0}&\textcolor{red}{0}\\
		\textcolor{red}{$aabab$}&\textcolor{red}{0}&\textcolor{red}{0}\\
		\hline
	\end{tabular}
\end{minipage}
\begin{minipage}{0.33\linewidth}
	\centering
	\begin{tabular}{|c|cc|}
		\hline
		$O_4$ & $\epsilon$ & $a$\\
		\hline
		$\epsilon$ & 0 &0\\
		$a$&0&0\\
		$b$&0&1\\
		$aa$&0&0\\
		\textcolor{red}{$ab$}&\textcolor{red}{0}&\textcolor{red}{1}\\
		$ba$&1&1\\
		$aab$&0&0\\
		$aaba$&0&0\\
		\hline
		$bb$&0&1\\
		$aaa$&0&0\\
		\textcolor{red}{$aba$}&\textcolor{red}{1}&\textcolor{red}{1}\\
		\textcolor{red}{$abb$}&\textcolor{red}{0}&\textcolor{red}{1}\\
		$baa$&1&1\\
		$bab$&1&1\\
		$aabb$&0&0\\
		$aabaa$&0&0\\
		$aabab$&0&0\\
		\hline
	\end{tabular}
\end{minipage}
\begin{minipage}{0.33\linewidth}
	\centering
	\begin{tabular}{|c|ccccc|}
		\hline
		$O_7$ & $\epsilon$ & $a$&\textcolor{red}{$b$}&\textcolor{red}{$ab$}&\textcolor{red}{$ba$}\\
		\hline
		$\epsilon$&0&0&\textcolor{red}{0}&\textcolor{red}{1}&\textcolor{red}{1}\\
		$a$&0&0&\textcolor{red}{0}&\textcolor{red}{0}&\textcolor{red}{1}\\
		$b$&0&1&\textcolor{red}{0}&\textcolor{red}{1}&\textcolor{red}{1}\\
		$aa$&0&0&\textcolor{red}{0}&\textcolor{red}{0}&\textcolor{red}{0}\\
		$ab$&0&1&\textcolor{red}{0}&\textcolor{red}{1}&\textcolor{red}{1}\\
		$ba$&1&1&\textcolor{red}{1}&\textcolor{red}{1}&\textcolor{red}{1}\\
		$aab$&0&0&\textcolor{red}{0}&\textcolor{red}{0}&\textcolor{red}{0}\\
		$aaba$&0&0&\textcolor{red}{0}&\textcolor{red}{0}&\textcolor{red}{0}\\
		\hline
		$bb$&0&1&\textcolor{red}{0}&\textcolor{red}{1}&\textcolor{red}{1}\\
		$aaa$&0&0&\textcolor{red}{0}&\textcolor{red}{0}&\textcolor{red}{0}\\
		$aba$&1&1&\textcolor{red}{1}&\textcolor{red}{1}&\textcolor{red}{1}\\
		$abb$&0&1&\textcolor{red}{0}&\textcolor{red}{1}&\textcolor{red}{1}\\
		$baa$&1&1&\textcolor{red}{1}&\textcolor{red}{1}&\textcolor{red}{1}\\
		$bab$&1&1&\textcolor{red}{1}&\textcolor{red}{1}&\textcolor{red}{1}\\
		$aabb$&0&0&\textcolor{red}{0}&\textcolor{red}{0}&\textcolor{red}{0}\\
		$aabaa$&0&0&\textcolor{red}{0}&\textcolor{red}{0}&\textcolor{red}{0}\\
		$aabab$&0&0&\textcolor{red}{0}&\textcolor{red}{0}&\textcolor{red}{0}\\
		\hline
	\end{tabular}
\end{minipage}

	\begin{figure}[H]
		\centering
		\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm, semithick, bend angle=10]
		\tikzstyle{every state}=[circle]

		\node[initial, state] (A) {$[[\epsilon]]$};
		\node[state] (B) [above right of=A] {$[[a]]$};
		\node [state] (E) [right of=B] {$[[aa]]$};
		\node[state] (C) [below right of =A] {$[[b]]$};
		\node[accepting, state] [right of=C] (D) {$[[ba]]$};

		\path
		(A) edge node {a} (B)
		(A) edge node {b} (C)
		(B) edge node {b} (C)
		(B) edge node {a} (E)
		(C) edge [loop below] node {b} (C)
		(C) edge node {a} (D)
		(D) edge [loop above] node {a,b} (D)
		(E) edge [loop below] node {a,b} (E);

		\end{tikzpicture}
		\caption*{Automate $O_7$}
	\end{figure}


Ayant reçu $aaba$, ce mot et tous ses préfixes sont ajoutés à la table. L'extension $R.\Sigma$ est recalculée et la table $O_3$ est construite.

Un manquement est détecté : le mot $a$. En effet, en lui ajoutant le symbole $b$, on obtient $ab$ qui n'est ni dans $R$ ni en relation $R_O$ avec $a$. $ab$ est alors ajouté à $R$, et $R.\Sigma$ est étendu. La nouvelle table, $O_4$ est de nouveau testée.

$O_4$ ne respecte pas la cohérence. Les mots $\epsilon$ et $aa$ respectent \ro (leur ligne a la même valeur dans la table) mais $\neg b R_O aab$. $b$ est alors ajouté à $S$ et une nouvelle colonne associée est ajoutée à la table, donnant le table $O_5$. Celle-ci a toujours un soucis de cohérence entre $\epsilon$ et $aa$, menant à l'ajout de $ab$ à $S$ et à la création de $O_6$. Finalement, pour régler le soucis de cohérence dans $O_6$ entre $a$ et $aa$, le mot $ba$ est ajouté à $S$ et une table $O_7$ est ainsi créée avec la nouvelle colonne associée.

Cette table $O_7$ respectant la clôture et la cohérence, l'automate associé $O_7$ est construit et soumis à l'enseignant pour être comparé à $A_3$. Celui-ci valide l'égalité et l'algorithme s'arrête : l'automate a été construit.
