L'algorithme d'Angluin repose, en plus des éléments précédents sur quatre concepts :

\begin{itemize}
	\item Une table d'observation
	\item La relation $R_O$, se basant sur la table d'observation et semblable à la relation $R_L$
	\item La propriété de fermeture (closure en anglais)
	\item La propriété de cohérence (consistence en anglais)
\end{itemize}

Cette section commence par décrire cette table en \ref{ss:a_tblo}, la relation $R_O$ en \ref{ss:a_ro}, la fermeture en \ref{ss:a_fermeture}, la cohérence en \ref{ss:a_coherence}.

Une fois toutes ces bases posées, une exécution de l'algorithme sur un exemple est proposée en \ref{ss:a_exemple}, suivie du fonctionnement formel de l'algorithme et des preuves sur son exactitude et sa complexité en \ref{ss:a_algo}, \ref{ss:a_proof} et \ref{ss:a_comp}.


% ██████  ██
% ██   ██ ██
% ██████  ██
% ██   ██ ██
% ██   ██ ███████

\subsection{La relation \rl}

Soit un langage $L$ sur un alphabet $\Sigma$.

Soit la relation $R_L$ portant sur deux mots (ne faisant pas nécessairement partie de $L$). Deux mots $x$ et $y$ respectent la relation de Myhill-Nérode $R_L$ si

$$\forall z \in \Sigma^*, xz \in L \Leftrightarrow yz \in L$$

Intuitivement, deux mots sont en relation si pour tout mot qu'on leur concatène, les deux mots résultants sont tous deux dans le langage ou non.

\begin{lemma}
	Cette relation est une relation d'équivalence. De plus, elle respecte la congruence à droite. C'est à dire que si $xR_Ly$, alors pour tout symbole $a \in \Sigma$, $xaR_Lya$
\end{lemma}

\begin{proof}[Equivalence et Congruence à droite]
	Dire d'une relation qu'elle décrit une équivalence, revient à dire qu'elle est réflexive, transitive et symétrique
\begin{itemize}
		\item $R_L$ est réflexive. Soit $x \in \Sigma^*$. Soit $z \in \Sigma^*$. Montrer que $xR_Lx$ est vrai revient à montrer que $ xz \in L \Leftrightarrow xz \in L$ est vrai. $R_L$ est donc réflexive.
		\item $R_L$ est symétrique. Soient $x, y \in \Sigma^*$ tels que $xR_Ly$. Soit $w \in \Sigma^*$. Montrer que $yR_Lx$ revient à montrer que $ yw \in L \Leftrightarrow xw \in L$. Or, par hypothèse, $ xz \in L \Leftrightarrow yz \in L$, qui peut s'écrire aussi $ yz \in L \Leftrightarrow xz \in L$ pour tout $z \in \Sigma^*$, et en particulier $z=w$.
		\item $R_L$ est transitive. Soient $x,y,u \in \Sigma^*$ tels que $xR_Ly$ et $yR_Lz$. Soit $w \in \Sigma^*$. Comme $ xz \in L \Leftrightarrow yz \in L$ et $ yz \in L \Leftrightarrow uz \in L$ pour tout $z \in \Sigma^*$ (par hypothèse), c'est vrai en particulier pour $z=w$. Dès lors,  $ xw \in L \Leftrightarrow yw \in L$et $ yw \in L \Leftrightarrow uw \in L$. Par transitivité de l'implication, on obtient $ xw \in L \Leftrightarrow uw \in L$, à savoir $xR_Lu$.
		\item $R_L$ est congruente à droite. Soient $x,y \in \Sigma^*$ tels que $xR_Ly$. Soit $a \in \Sigma$. Par hypothèse, $ xz \in L \Leftrightarrow yz \in L$ pour tout $z \in \Sigma^*$. Cela doit donc être vrai en particulier pour le mot $z=aw$ avec $w$ quelconque. En remplaçant dans l'hypothèse, on obtient  $ xaw \in L \Leftrightarrow yaw \in L$. Ce qui montre que $xaR_Lya$.
	\end{itemize}

\hfill$\square$
\end{proof}

% ███    ██ ███████ ██████   ██████  ██████  ███████
% ████   ██ ██      ██   ██ ██    ██ ██   ██ ██
% ██ ██  ██ █████   ██████  ██    ██ ██   ██ █████
% ██  ██ ██ ██      ██   ██ ██    ██ ██   ██ ██
% ██   ████ ███████ ██   ██  ██████  ██████  ███████

\subsection{Théorème de Myhill-Nerode}

	\begin{theorem}
		Les 3 énoncés suivants sont équivalents :
		\begin{enumerate}
			\item Un langage $L\subseteq\Sigma^*$ est accepté par un DFA
			\item $L$ est l'union de certaines classes d'équivalence d'index fini respectant une relation d'équivalence et de congruence à droite
			\item Soit la relation d'équivalence $R_L : xR_Ly \Leftrightarrow \forall z \in \Sigma^*, xz \in L \Leftrightarrow yz \in L$ (la relation de Myhill-Nérode définie précédemment). $R_L$ est d'index fini.
		\end{enumerate}
	\end{theorem}

	\begin{proof}La preuve d'équivalence se fait en prouvant chaque implication de façon cyclique :\\

		$(1)\rightarrow(2)$ Supposons que (1) soit vrai, c'est à dire que le langage $L$ est accepté par un automate déterministe fini $A$. Considérons la relation d'équivalence $R_M$ étant vraie pour les mots $x,y$ si $\hat{\delta}(q_0,x)\in F \iff \hat{\delta}(q_0,y)\in F$. Elle a été définie en \ref{ss:rm}. Il y est prouvé qu'elle est congruente à droite. Comme il y a au plus une classe d'équivalence pour $R_M$ par état de $A$. Comme ce nombre d'états est fini, $R_M$ est d'index fini. De plus, $L$ est l'union de classes contenant un mot $w$ tel que $\hat{\delta}(q_0,w) \in F$, (or, ce chemin retourne un état. Il s'agit donc d'une union des classes correspondant aux états acceptants).

		$(2)\rightarrow(3)$ Montrons que pour toute relation $E$ satisfaisant (2), chaque classe est intégralement contenue dans une seule classe de $R_L$. Ces classes étant d'index fini, c'est un argument suffisant pour déduire que $R_L$ est d'index fini. Considérons $x,y$ tels que $xEy$. Comme $E$ est congruente à droite, pour tout mot $z \in \Sigma^*$, on sait que $xzEyz$. Comme $L$ est un union de ces classes d'équivalence, $xzEyz$ implique que $xz \in L \Leftrightarrow yz \in L$, ce qui revient à $xR_Ly$. Cela signifie que tout mot dans la classe d'équivalence de $x$ définie par $E$ se retrouve dans la même classe d'équivalence que $x$ par $R_L$. Ce qui permet de conclure que chaque classe d'équivalence de $E$ est contenue dans une classe d'équivalence de $R_L$.


		$(3)\rightarrow(1)$ Considérons la relation $R_L$ définie précédemment, et déduisons-en $Q'$ les classes d'équivalence sur $L$ et $[[x]]$ l'élément(la classe) de $Q'$ qui contient $x$. Puisque $R_L$ a été démontré comme congruent à droite, on peut définir des transitions : $\delta'([[x]],a) = [[xa]]$. En choisissant un élément $y$ dans $[[x]]$ (ce qui signifie que $xR_Ly$), on obtient $\delta'([[x]],a)=[[ya]]$. Sauf que par définition, $xR_Ly$ signifie qu'en y ajoutant n'importe quel mot $z$, $xz$ et $yz$ appartiennent tous deux où non à $L$. C'est vrai en particulier pour $z=az'$. Ainsi, $xaz'$ et $yaz'$ appartiennent tous deux à $L$ ou non. Ce qui signifie que $xaR_Lya$ et donc $[[xa]]=[[ya]]$. Posons $q_0'=[[\epsilon]]$ et $F' = \{[[x]]|x \in L\}$. Tous ces éléments forment l'automate $M'=(Q', \Sigma, \delta', q_0', F')$. Il est déterministe par la définition de $\delta'$, fini car $Q'$ est fini par construction (le nombre de classes d'équivalence est fini). De plus, il accepte $L$ puisque $\delta'(q_0',x)=[[x]]$, ce qui signifie que $x \in L(M')$ si et seulement si $[[x]] \in F'$, qui a été défini comme tel.


		\hfill$\square$
	\end{proof}


	\begin{corollary}
		Grâce à la preuve du théorème de Myhill-Nérode, en particulier la justification partant de la relation d'équivalence $R_L$ pour montrer que la langage $L\subseteq\Sigma^*$ est accepté par un DFA, on a une méthode pour construire un automate à partir d'un langage.
	\end{corollary}


  % ████████  ██████
  %    ██    ██    ██
  %    ██    ██    ██
  %    ██    ██    ██
  %    ██     ██████

  \subsection{La table d'observation}

  % ███████ ███████ ██████  ███    ███  ██████  ██████  ██   ██ ███████
  % ██      ██      ██   ██ ████  ████ ██      ██    ██ ██   ██ ██
  % █████   █████   ██████  ██ ████ ██ ██      ██    ██ ███████ █████
  % ██      ██      ██   ██ ██  ██  ██ ██      ██    ██ ██   ██ ██
  % ██      ███████ ██   ██ ██      ██  ██████  ██████  ██   ██ ███████


\subsection{Fermeture et cohérence}

\subsubsection*{Fermeture}
La propriété de fermeture (closure) s'exprime mathématiquement par

$$ \forall u \in R, \forall a \in \Sigma, \exists v \in R, ua R_O v$$

Cette propriété peut être vérifiée par cet algorithme, expliqué de façon visuelle sur la table O :

\begin{algorithm}[H]
	\begin{algorithmic}[1]
		\ENSURE si la fermeture est respectée ou non

		\FORALL {élément $w$ de la section $R$}
		\FORALL {symbole $a$ dans $\Sigma$}
			\IF {$wa$ est dans $R$}
				\STATE continuer
			\ELSE
				\STATE \COMMENT{$wa$ est dans $R.\Sigma$ par construction}
				\IF {La ligne de $wa$ dans $T$ est différente de celle de $w$}
					\RETURN Faux
				\ENDIF
			\ENDIF
		\ENDFOR
		\ENDFOR
		\RETURN Vrai
	\end{algorithmic}
	\caption{Vérification de la fermeture}\label{alg:closure}
\end{algorithm}

\subsubsection*{Cohérence}

La propriété de \emph{cohérence} (consistence) se définit mathématiquement comme

$$ \forall u,v \in R, u R_O v \Rightarrow \forall a \in \Sigma, ua R_O va$$

Concrètement, il s'agit de prendre deux mots ($u,v$) dans $R$ ayant la même ligne dans $T$ et vérifier, pour chaque symbole ($a$), s'ils ($ua,va$) ont la même ligne dans $T$.



%  █████  ██       ██████   ██████
% ██   ██ ██      ██       ██    ██
% ███████ ██      ██   ███ ██    ██
% ██   ██ ██      ██    ██ ██    ██
% ██   ██ ███████  ██████   ██████

\subsection{L'algorithme}
Considérons l'automate $A_3$ de la figure \ref{fig:a3} construit à la section \ref{ss:miniauto} sur la minimisation.

\todo{Marquer la différence entre $R_L$ et $R_O$}

\subsubsection{Première itération}

L'algorithme d'Angluin précise, pour son cas de base, une initialisation de la table $T$ avec les ensembles $R$ et $S$ contenant uniquement $\epsilon$. Le champ $R.\{a,b\}$ ($R.\Sigma$) est rempli via des requête d'appartenance sur les mots $a$ et $b$.

\begin{minipage}{0.5\linewidth}
	\centering
	\begin{tabular}{|c|c|}
		\hline
		$O_0$ & $\epsilon$\\
		\hline
		$\epsilon$ & 0\\
		\hline
		$a$ & 0\\
		$b$ & 0\\
		\hline
	\end{tabular}
\end{minipage}
\begin{minipage}{0.5\linewidth}
	\centering
	\begin{figure}[H]
		\centering
		\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm, semithick, bend angle=10]
		\tikzstyle{every state}=[circle]
		\node[initial, state] (A) {$[[\epsilon]]$};
		\path (A) edge [loop above] node {a,b} (A);
		\end{tikzpicture}
		\caption*{Automate $O_0$}
	\end{figure}
\end{minipage}


\vspace{1cm}
L'étape suivante consiste à vérifier la \emph{closure} de la table d'observation $O_0$. Mathématiquement :

$$ \forall u \in R, \forall a \in \Sigma, \exists v \in R, ua R_L v$$

Intuitivement, pour chaque symbole (ici, $\{a,b\}$, et ce sera vrai jusqu'à la dernière itération), tout mot candidat (dans $R$, la partie supérieure de la table) doit se retrouver, complété de ce symbole, dans une classe d'équivalence d'un autre candidat de $R$. Ici, de toute évidence, les mots $a$ et $b$ sont dans la même classe d'équivalence que $\epsilon$. Dès lors, la propriété de \emph{closure} est respectée.

Si la \emph{closure} est respectée, alors la question de la \emph{consistence} (cohérence) se pose. Mathématiquement :

$$ \forall u,v \in R, u R_L v \Rightarrow \forall a \in \Sigma, ua R_L va$$

Intuitivement, si deux candidats semblent être dans la même classe d'équivalence (leur lignes dans la table supérieure sont identiques), alors pour n'importe quel symbole, les deux nouveaux mots sont également dans une même classe d'équivalence (leur lignes, potentiellement dans la partie inférieure de la table, sont identiques). N'ayant qu'un seul candidat, cette propriété est forcément respectée ($R_L$ est réflexive).

Les deux propriétés étant respectées, les classes d'équivalences sont calculées (trivialement ici), et un automate $O_0$ est proposé à l'enseignant pour vérification.

Sur cette itération, un automate initial a été proposé, et aucun état final ne pouvant être atteint avec un seul symbole, la version est minime.

\subsubsection{Seconde itération}

L'enseignant répond que non, les automates ne sont pas équivalents. Il fourni le contre-exemple $ba$. Comme il est rejeté par $O_0$, cela signifie qu'il est accepté par $A_4$. Une nouvelle table est alors construite, en ajoutant $ba$ et ses préfixes (ici, juste $b$) à $R$. $R.\Sigma$ est calculé et les mots n'ayant pas encore reçu une valeur dans $T$ sont soumis à l'enseignant pour un test d'appartenance.
\vspace{1cm}

\begin{minipage}{0.25\linewidth}
	\centering
	\begin{tabular}{|c|c|}
		\hline
		$O_1$ & $\epsilon$\\
		\hline
		$\epsilon$ & 0\\
		\textcolor{red}{$b$} & \textcolor{red}{0}\\
		\textcolor{red}{$ba$} & \textcolor{red}{1}\\
		\hline
		$a$ & 0\\
		\textcolor{red}{$bb$} & \textcolor{red}{0}\\
		\textcolor{red}{$baa$} & \textcolor{red}{1}\\
		\textcolor{red}{$bab$} & \textcolor{red}{1}\\
		\hline
	\end{tabular}
\end{minipage}
\begin{minipage}{0.25\linewidth}
	\centering
	\begin{tabular}{|c|cc|}
		\hline
		$O_2$ & $\epsilon$ & \textcolor{red}{$a$}\\
		\hline
		$\epsilon$ & 0& \textcolor{red}{0}\\
		$b$ & 0&\textcolor{red}{1}\\
		$ba$ & 1&\textcolor{red}{1}\\
		\hline
		$a$ & 0&\textcolor{red}{0}\\
		$bb$ & 0&\textcolor{red}{1}\\
		$baa$ & 1&\textcolor{red}{1}\\
		$bab$ & 1&\textcolor{red}{1}\\
		\hline
	\end{tabular}
\end{minipage}
\begin{minipage}{0.5\linewidth}
	\centering
	\begin{figure}[H]
		\centering
		\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm, semithick, bend angle=10]
		\tikzstyle{every state}=[circle]

		\node[initial, state] (A) {$[[\epsilon]]$};
		\node[state] (B) [right of=A] {$[[b]]$};
		\node[accepting, state] [right of=B] (C) {$[[ba]]$};

		\path
		(A) edge [loop above] node {a} (A)
		(A) edge node {b} (B)
		(B) edge node {a} (C)
		(B) edge [loop above] node {b} (B)
		(C) edge [loop above] node {a,b} (C);


		\end{tikzpicture}
		\caption*{Automate $O_2$}
	\end{figure}
\end{minipage}

\vspace{1cm}
Comme pour la première itération, la \emph{fermeture} est testée, suivie de la \emph{cohérence}. Celle-ci n'est pas respectée : si on considère les mots $\epsilon$ et $b$, qui ont la même ligne dans la table $T$ ($\epsilon R_O b$), le symbole $a$, on obtient les mots $a$ et $ba$ qui n'ont pas la même ligne : ($\not a R_O ba$). Le symbole $a$ est alors ajouté à $S$ et une nouvelle table $O_2$ est calculée.

La fermeture étant déjà vérifiée, la question de la cohérence est reposée, et cette fois-ci elle est vérifiée ; l'automate est construit et proposé à l'enseignant.

Sur cette itération, l'algorithme a reçu le mot $ba$ comme étant accepté. Il a du ajouter $a$ à $S$ pour permettre de différencier certains états. L'automate se voit ajouter les états $[[b]]$ et $[[ba]]$.

\subsubsection{Troisième itération}

Suivant toujours l'algorithme de comparaison d'automates détaillé dans la section \ref{sec:algorithmes}, l'enseignant découvre qu'ils sont différents.

Il sort le contre-exemple $aaba$. Si c'est un contre-exemple et qu'il est accepté par $O_2$, c'est qu'il ne l'est pas (0) par $A_4$. Une nouvelle table $O_3$ doit être construite.

\begin{minipage}{0.33\linewidth}
	\centering
	\begin{tabular}{|c|cc|}
		\hline
		$O_3$ & $\epsilon$ & $a$\\
		\hline
		$\epsilon$ & 0 &0\\
		\textcolor{red}{$a$}&\textcolor{red}{0}&\textcolor{red}{0}\\
		$b$&0&1\\
		\textcolor{red}{$aa$}&\textcolor{red}{0}&\textcolor{red}{0}\\
		$ba$&1&1\\
		\textcolor{red}{$aab$}&\textcolor{red}{0}&\textcolor{red}{0}\\
		\textcolor{red}{$aaba$}&\textcolor{red}{0}&\textcolor{red}{0}\\
		\hline
		\textcolor{red}{$ab$}&\textcolor{red}{0}&\textcolor{red}{1}\\
		$bb$&0&1\\
		\textcolor{red}{$aaa$}&\textcolor{red}{0}&\textcolor{red}{0}\\
		$baa$&1&1\\
		$bab$&1&1\\
		\textcolor{red}{$aabb$}&\textcolor{red}{0}&\textcolor{red}{0}\\
		\textcolor{red}{$aabaa$}&\textcolor{red}{0}&\textcolor{red}{0}\\
		\textcolor{red}{$aabab$}&\textcolor{red}{0}&\textcolor{red}{0}\\
		\hline
	\end{tabular}
\end{minipage}
\begin{minipage}{0.33\linewidth}
	\centering
	\begin{tabular}{|c|cc|}
		\hline
		$O_4$ & $\epsilon$ & $a$\\
		\hline
		$\epsilon$ & 0 &0\\
		$a$&0&0\\
		$b$&0&1\\
		$aa$&0&0\\
		\textcolor{red}{$ab$}&\textcolor{red}{0}&\textcolor{red}{1}\\
		$ba$&1&1\\
		$aab$&0&0\\
		$aaba$&0&0\\
		\hline
		$bb$&0&1\\
		$aaa$&0&0\\
		\textcolor{red}{$aba$}&\textcolor{red}{1}&\textcolor{red}{1}\\
		\textcolor{red}{$abb$}&\textcolor{red}{0}&\textcolor{red}{1}\\
		$baa$&1&1\\
		$bab$&1&1\\
		$aabb$&0&0\\
		$aabaa$&0&0\\
		$aabab$&0&0\\
		\hline
	\end{tabular}
\end{minipage}
\begin{minipage}{0.33\linewidth}
	\centering
	\begin{tabular}{|c|cc|}
		\hline
		$O_5$ & $\epsilon$ & $a$\\
		\hline
		$\epsilon$ & 0 &0\\
		$a$&0&0\\
		$b$&0&1\\
		$aa$&0&0\\
		$ab$&0&1\\
		$ba$&1&1\\
		$aab$&0&0\\
		\textcolor{red}{$aba$}&\textcolor{red}{1}&\textcolor{red}{1}\\
		$aaba$&0&0\\
		\hline
		$bb$&0&1\\
		$aaa$&0&0\\
		$abb$&0&1\\
		$baa$&1&1\\
		$bab$&1&1\\
		$aabb$&0&0\\
		\textcolor{red}{$abaa$}&\textcolor{red}{1}&\textcolor{red}{1}\\
		\textcolor{red}{$abab$}&\textcolor{red}{1}&\textcolor{red}{1}\\
		$aabaa$&0&0\\
		$aabab$&0&0\\
		\hline
	\end{tabular}
\end{minipage}



	\begin{figure}[H]
		\centering
		\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm, semithick, bend angle=10]
		\tikzstyle{every state}=[circle]

		\node[initial, state] (A) {$[[\epsilon]]$};
		\node[state] (B) [above right of=A] {$[[a]]$};
		\node [state] (E) [right of=B] {$[[aa]]$};
		\node[state] (C) [below right of =A] {$[[b]]$};
		\node[accepting, state] [right of=C] (D) {$[[ba]]$};

		\path
		(A) edge node {a} (B)
		(A) edge node {b} (C)
		(B) edge node {b} (C)
		(B) edge node {a} (E)
		(C) edge [loop below] node {b} (C)
		(C) edge node {a} (D)
		(D) edge [loop above] node {a,b} (D)
		(E) edge [loop below] node {a,b} (E);

		\end{tikzpicture}
		\caption*{Automate $O_5$}
	\end{figure}


Ayant reçu $aaba$, ce mot et tous ses préfixes sont ajoutés à la table. L'extension $R.\Sigma$ est recalculée et la table $O_3$ est construite.

Ensuite, la question de la \emph{fermeture} est posée. Un manquement est détecté : le mot $a$. En effet, en lui ajoutant le symbole $b$, on obtient $ab$ qui n'est ni dans $R$ ni en relation $R_O$ avec $a$. $ab$ est alors ajouté à $R$, et $R.\Sigma$ est étendu. La nouvelle table, $O_4$ est de nouveau testée.

$O_4$ ne respecte pas la fermeture : le mot $ab$, agrémenté du symbole $a$ donne le mot $aba$, qui n'est ni dans $R$ ni en relation avec $ab$. Le mot est ajouté à $R$, et la table est étendue. La nouvelle table, $O_5$ est à la fois fermée et cohérente.

L'automate $O_5$ est alors proposé à l'enseignant pour vérification. Celui-ci est accepté (isomorphe à $A_4$). L'algorithme s'arrête et un automate minimal pour le langage a été construit.
