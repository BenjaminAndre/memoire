
% ██      ██    █████
% ██       ██  ██   ██
% ██ █████  ██ ███████
% ██       ██  ██   ██
% ███████ ██   ██   ██

\subsection{Construction d'un automate depuis un langage régulier}

Comme vu dans la section \ref{ss:e-a}, il est intéressant de pouvoir convertir un problème sur un langage régulier en test d'appartenance à un automate. Il est cependant possible de le faire directement depuis le langage régulier grâce au théorème de Myhill-Nérode et à la relation \rl.

Soit le langage $A_N = \{w | w \text{finit par b et ne contient pas bb}\}$ défini sur $\Sigma_N = {a,b}$. Ce langage peut être écrit sous forme d'une expression régulière $E=a^*(ba)^*b$, ce qui confirme que le langage est régulier.

On peut diviser les mots de ce langage en 3 ensembles :

\begin{itemize}
 \item $W_0$ le sous-ensemble des mots ne finissant pas le symbole $b$
 \item $W_1$ celui des mots finissant par le symbole $b$ mais ne contenant pas $bb$
 \item $W_2$ celui des mots contenant au moins $bb$
\end{itemize}

Il y a d'autres façons de construire des sous-ensembles, mais celle-ci à l'avantage de rendre la question de l'appartenance à $L_N$ triviale : un mot appartient au second ensemble si et seulement si il fait partie du langage, par définition.

De plus, tous les éléments d'un sous-ensemble respectent la relation $R_L$ entre eux. ($R_L : xR_Ly \Leftrightarrow \forall z \in \Sigma^*, xz \in L \Leftrightarrow yz \in L$). Cela en fait des classes d'équivalence sur cette relation.

Cela peut être démontré pour chaque sous-ensemble :
\begin{itemize}
 \item Soient $x,y \in W_0$. Soit $z \in \Sigma^*$. Dès lors, si $xz \in L_N$, c'est que $z$ fini par $b$ mais ne contient pas $bb$, et donc $yz \in L_N$. Si $yz \in L_N$, le même argument peut être appliqué.
 \item Soient $x,y \in W_1$. Soit $z \in \Sigma^*$. Dès lors, si $xz \in L_N$, c'est que $z$ ne commençait pas le symbole $b$ et ne contenait pas $bb$, $yz$ ne contiendra donc pas $bb$, puisque cette chaîne n'est ni dans $z$ ni dans $y$, ni a cheval sur les deux, $z$ ne commençant pas par $b$. Ainsi, $yz \in L_N$. Si $yz \in L_N$, le même argument peut être appliqué.
 \item Soient $x,y \in W_2$. Soit $z \in \Sigma^*$. Comme $x$ contient déjà $bb$, $x \notin L_N$ et, a fortiori, $xz \notin L_N$. Comme la prémisse est fausse, l'implication $xz \in L \Rightarrow yz \in L$ est vraie. La même logique peut être appliquée à partir de $y$ pour justifier l'implication inverse.
\end{itemize}

De plus, ces sous-ensembles sont disjoints de par leur construction.

Ceci revient à démontrer que $W_0,W_1,W_2$ sont des classes d'équivalence. De plus, $R_L$ respecte la congruence à droite, comme démontré dans la preuve du théorème de Myhill-Nérode. Ce même théorème donne une méthode pour construire un automate : prendre un représentant pour chaque classe et en faire un état.

\begin{itemize}
 \item $\Sigma=\{a,b\}$ est connu.
 \item $Q=\{[[\epsilon]]\, [[b]], [[bb]]\} = \{q_\epsilon, q_b, q_{bb}\}$
 \item $q_0 = q_\epsilon$
 \item $F = \{q_b\}$ l'union des classes acceptant
 \item $\delta$ défini en utilisant des exemples tirés des classes d'équivalence.
\end{itemize}

Ce qui donne l'automate de la figure \ref{fig:an}

\begin{figure}[H]
 \centering
 \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm and 2cm, semithick, bend angle=10]

 \tikzstyle{every state}=[circle]

 \node[initial,state]	(A)					{$q_\epsilon$};
 \node[accepting,state]	(B)	[right= of A]	{$q_b$};
 \node[state]			(C) [right= of B]	{$q_{bb}$};

 \path
 (A)	edge	[bend left]		node{b}		(B)
 (A)	edge	[loop above]	node{a}		(A)
 (B) edge	[bend left]		node{a}		(A)
 (B) edge					node{b}		(C)
 (C)	edge	[loop above]	node{a,b}	(C)

 ;
 \end{tikzpicture}
 \caption{Automate $A_N$, exemple issu de la thèse\cite{Neider14}}\label{fig:an}
\end{figure}

Cet automate est bien une représentation du langage $L_N$. Seul un mot finissant par $b$ mais ne contenant pas $bb$ se termine à l'état $q_b$.



  %  █████  ██████  ██████
  % ██   ██ ██   ██ ██   ██
  % ███████ ██████  ██████
  % ██   ██ ██   ██ ██
  % ██   ██ ██████  ██

  \subsection{Alternating Bit Protocol}\label{ss:abp}

  \begin{figure}[H]
    \centering
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3.5cm, semithick, bend angle=10]

      \tikzstyle{every state}=[circle]

      \node[initial,state] (A)                    {$q_0$};
      \node[state]         (B) [right of=A] {$q_1$};
      \node[state]         (C) [below of=B] {$q_2$};
      \node[state]         (D) [left of=C] {$q_3$};

      \node[state,draw=none]         (i1) [right=0cm of B]      {};
      \node[state,draw=none]         (i2) [right=3.5cm of i1]      {};
      \node[state,draw=none]         (i3) [right=0cm of C]      {};
      \node[state,draw=none]         (i4) [right=3.5cm of i3]      {};

      \node[state] (E) [right=0cm of i2]               {$q_{0'}$};
      \node[state]         (F) [right of=E] {$q_{1'}$};
      \node[state]         (G) [below of=F] {$q_{2'}$};
      \node[state]         (H) [left of=G] {$q_{3'}$};



      \path
      (A) edge node {$\theta_1(A!0)$} (B)
      (B) edge node {$\theta_4(B?ACK0)$} (C)
      (B) edge[loop above] node {$\theta_2(A!0),\theta_3(B?ACK1)$} (B)
      (C) edge node {$\theta_5(A!1)$} (D)
      (D) edge node {$\theta_8(B?ACK1)$} (A)
      (D) edge[loop below] node {$\theta_6(A!1),\theta_7(B?ACK0)$} (D)


      (E) edge node {$\theta_{11}(A?0)$} (F)
      (E) edge[loop above] node {$\theta_9(B!ACK1),\theta_{10}(A?1)$} (E)
      (F) edge node {$\theta_{12}(B!ACK0)$} (G)
      (G) edge node {$\theta_{15}(A?1)$} (H)
      (G) edge[loop below] node {$\theta_{13}(B!ACK0),\theta_{14}(A?0)$} (G)
      (H) edge node {$\theta_{16}(B!ACK1)$} (E)
      ;

      \draw[<-] (E) -- node[above left] {start} ++(-1cm,-1cm);

      \draw[double,->] (i1) -- node[above] {canal A} (i2);
      \draw[double,->] (i4) -- node[below] {canal B} (i3);
    \end{tikzpicture}
    \caption{Automate Fifo du ABP (\cite{Finkel03}, Fig.1.)}\label{fig:fifoabp}
  \end{figure}
