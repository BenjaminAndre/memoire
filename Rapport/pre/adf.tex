Cette section décrit les automates déterministes finis (ADF) en \ref{adf:def} et en propose une représentation en \ref{adf:repr}. Par après, le langage correspondant est défini en \ref{adf:lang}.  Les notations utilisées dans cette section s'appuyent principalement sur \cite{Hopcroft79}, \cite{Hopcroft00} et \cite{Kozen97}.

En plus des automates déterministes finis, les automates non-déterministes finis avec ou sans transition sur $\epsilon$ sont également définis. Leur unique utilité dans le cadre de ce mémoire est de permettre de prouver l'équivalence entre un automate déterministe fini et une expression régulière en \ref{adf:eq}. Cette dernière section permet dès lors de passer d'une expression régulière à un automate et vice-versa, ce qui est utile lors de l'apprentissage d'un langage.

Pour facilité la construction du langage et de l'algorithme d'équivalence, une fonction eclose est définie en \ref{adf:eclose}.


% ██████  ███████ ███████ ██ ███    ██ ██ ████████ ██  ██████  ███    ██
% ██   ██ ██      ██      ██ ████   ██ ██    ██    ██ ██    ██ ████   ██
% ██   ██ █████   █████   ██ ██ ██  ██ ██    ██    ██ ██    ██ ██ ██  ██
% ██   ██ ██      ██      ██ ██  ██ ██ ██    ██    ██ ██    ██ ██  ██ ██
% ██████  ███████ ██      ██ ██   ████ ██    ██    ██  ██████  ██   ████

\subsection{Définitions}\label{adf:def}

Un \emph{automate fini} \automaton est défini comme suit :
\begin{itemize}
  \item $Q$ est un ensemble fini d'\emph{états}
  \item $\Sigma$ est un alphabet
  \item $q_0 \in Q$ est l'\emph{état initial}
  \item $\delta$ est la \emph{fonction de transition}
  \item $F \subseteq Q$ est un ensemble d'\emph{états acceptants}.
\end{itemize}

La fonction de transition $\delta$ est définie différemment en fonction du type d'automate souhaité :
\begin{itemize}
  \item \textbf{Automate Déterministe Fini (ADF)} $\delta : Q \times \Sigma \rightarrow Q$. Soit un état $q$ et un symbole $a$. Alors la \emph{transition} $\delta(q,a)$ retourne un état $p$. $\delta(q,a)$ doit être définie pour tout état et tout symbole.
  \item \textbf{Automate Non-déterministe Fini (ANF)} $\delta : Q \times \Sigma \rightarrow 2^Q$. Soit un état $q$ et un symbole $a$. Alors la transition $\delta(q,a)$ retourne un ensemble d'états $P=\{p_1,p_2,\dots,p_n\}\subseteq Q$.
  \item \textbf{Automate Non-déterministe Fini avec des transitions sur $\epsilon$ ($\epsilon$-ANF)} $\delta : Q \times \Sigma \cup \{\epsilon\} \rightarrow 2^Q$. Pareil que précédemment mais une transition peut exister sans symbole : elle se fait alors sur $\epsilon$.
\end{itemize}

Lorsqu'un automate est mentionné dans ce document, il s'agit implicitement d'un $\epsilon$-ANF, sauf mention contraire. En effet, c'est la forme la plus générale. Cependant, ces trois types d'automates ont la même puissance expressive, ce qui est prouvé dans la section \ref{ss:eqadfanf}.

Soit la transition $\delta(q,a)=p$ (dans un ADF). Pour $q$, c'est une \emph{transition sortante sur a}. Pour $p$, c'est une \emph{transition entrante sur a}.

Si $\delta(q,a)=P=\{p_1,p_2,\dots,p_n\}$ dans un ANF, alors les états $\{p_1,p_2,\dots,p_n\}$ auront une transition entrante sur $a$.

Dans le cas des ANFs et $\epsilon$-ANFs, il peut être pratique d'utiliser $\delta$ sur un ensemble d'états $S$. A ce moment, $\delta(S,a)=\bigcup_{q\in S}\delta(q,a)$ avec $a\in \Sigma$.


% ███████ ██   ██ ███████ ███    ███ ██████  ██      ███████ ███████
% ██       ██ ██  ██      ████  ████ ██   ██ ██      ██      ██
% █████     ███   █████   ██ ████ ██ ██████  ██      █████   ███████
% ██       ██ ██  ██      ██  ██  ██ ██      ██      ██           ██
% ███████ ██   ██ ███████ ██      ██ ██      ███████ ███████ ███████


\begin{example}[Automate déterministe fini]\label{ex:adf}
  On considère l'automate \automaton défini comme suit :
  \begin{itemize}
    \item $Q=\{q_0,q_1,q_2,q_3,q_4,q_5,q_6\}$
    \item $\Sigma=\{a,b\}$
    \item $q_0$ est l'état du même nom.
    \item La fonction de transition $\delta$ est décrite par la table \ref{table:transdelta}.
    \item $F=\{q_3\}$
  \end{itemize}

  \begin{table}[H]
    \centering
    \begin{tabular}{|r||c|c|}
      \hline
      &a&b\\
      \hline\hline
      $\rightarrow q_0$&$q_2$&$q_1$\\\hline
      $q_1$&$q_3$&$q_5$\\\hline
      $q_2$&$q_4$&$q_5$\\\hline
      $q_3^*$&$q_3$&$q_3$\\\hline
      $q_4$&$q_4$&$q_4$\\\hline
      $q_5$&$q_3$&$q_1$\\\hline
      $q_6$&$q_4$&$q_5$\\\hline
    \end{tabular}
    \caption{La \emph{table de transitions} $\delta$ d'un ANF}
    \label{table:transdelta}
  \end{table}
\end{example}

Cette table de transitions est construite comme suit :
\begin{itemize}
  \item Les en-têtes de colonnes sont des symboles $a\in\Sigma$.
  \item Les en-têtes de lignes sont des états $q \in Q$.
  \item Un cellule à la croisée de la ligne $q$ et du symbole $a$ contient un état $p$ avec $p=\delta(q,a)$.
\end{itemize}

Via la notation de la table \ref{table:transdelta}, $Q$ et $\Sigma$ sont explicites. En dénotant l'état initial par $\rightarrow$ et les états acceptants par $*$ en exposant, on obtient une définition complète d'un automate : $(Q,\Sigma, q_0, \delta, F)$.

\begin{example}[$\epsilon$-ANF]\label{ex:anf}
	 De la même façon que pour l'exemple précédent, considérons un automate \automaton défini comme suit :

\begin{itemize}
	\item $Q=\{q_0,q_1,q_2\}$
	\item $\Sigma=\{a,b,c\}$
	\item $q_0$ est l'état du même nom
	\item $\delta$ est donnée par la table \ref{table:eanfdelta}.
	\item $F=\{q_2\}$
\end{itemize}

$A$ est un $\epsilon$-ANF ; une colonne supplémentaire sert à représenter la transition sur $\epsilon$.

\begin{table}[H]
	\centering
	\begin{tabular}{|r||c|c|c|c|}
		\hline
		&$\epsilon$&a&b&c\\
		\hline\hline
		$\rightarrow q_0$&$\{q_1,q_2\}$&$\emptyset$&$\{q_1\}$&$\{q_2\}$\\\hline
		$q_1$&$\emptyset$&$\{q_0\}$&$\{q_2\}$&$\{q_0,q_1\}$\\\hline
		$q_2^*$&$\emptyset$&$\emptyset$&$\emptyset$&$\emptyset$\\\hline
	\end{tabular}
	\caption{La table de transitions $\delta$ d'un $\Sigma$-ANF}
	\label{table:eanfdelta}
\end{table}

Une table similaire sans la colonne $\epsilon$ représenterait un $ANF$ au sens strict. Celui-ci ne serait pas pour autant équivalent à l'$\epsilon-ANF$ de la table \ref{table:eanfdelta}.

\end{example}


%  ██████  ██████   █████  ██████  ██   ██
% ██       ██   ██ ██   ██ ██   ██ ██   ██
% ██   ███ ██████  ███████ ██████  ███████
% ██    ██ ██   ██ ██   ██ ██      ██   ██
%  ██████  ██   ██ ██   ██ ██      ██   ██


\subsection{Répresentation graphique}\label{adf:repr}
Le \emph{graphe d'un automate fini} \automaton est un graphe dirigé construit comme suit :

\begin{itemize}
  \item Chaque état de $Q$ est représenté par un nœud.
  \item Chaque transition $\delta(q,a)$ est représenté par un arc étiqueté $a$. Dans le cas d'un automate non-déterministe, un arc existe pour chacun des états obtenus en suivant la transition. Si il y a plusieurs transitions sortant d'un même état et entrant dans un même autre état, les arcs peuvent être fusionnés en listant les étiquettes.
  \item L'état initial est mis en évidence par une flèche entrante.
  \item Les états acceptants sont représentés par un double cercle, en opposition au simple cercle des autres nœuds.
\end{itemize}

\begin{example}[Graphe d'automate]
 Voici les graphes représentant les automates définis dans les tables \ref{table:transdelta} et \ref{table:eanfdelta} :

 \begin{minipage}[t]{0.5\textwidth}
   \begin{figure}[H]
    \centering
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm, semithick, bend angle=10]

    \tikzstyle{every state}=[circle]

    \node[initial,state] (A)                    {$q_0$};
    \node[state]         (B) [below right of=A] {$q_1$};
    \node[state]         (C) [below left of=A] {$q_2$};
    \node[accepting, state]         (D) [below right of=B] {$q_3$};
    \node[state]         (E) [below left of=C]       {$q_4$};
    \node[state]         (G) [below right of=E]       {$q_6$};
    \node[state]         (F) [above right of=G]       {$q_5$};

    \path 	(A) 	edge              node {a} (C)
    edge              node {b} (B)
    (B) 	edge              node {a} (D)
    edge [bend left]  node {b} (F)
    (C) 	edge              node {a} (E)
    edge              node {b} (F)
    (D) 	edge [loop above] node {a,b} (D)
    (E) 	edge [loop above] node {a,b} (E)
    (F) 	edge              node {a} (D)
    edge [bend left]  node {b} (B)
    (G) 	edge              node {a} (E)
    edge              node {b} (F);
    \end{tikzpicture}
    \caption{Graphe de l'ADF de la table \ref{table:transdelta}}\label{fig:a1}
   \end{figure}
 \end{minipage}
 \begin{minipage}[t]{0.5\textwidth}
   \begin{figure}[H]
   	\centering
   	\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm, semithick, bend angle=10]

   	\tikzstyle{every state}=[circle]

   	\node[initial,state] (A)                    {$q_0$};
   	\node[state]         (B) [above right of=A] {$q_1$};
   	\node[accepting, state]         (C) [below right of=A] {$q_2$};

   	\path
   	(A) edge [bend left] node{$\epsilon$,b} (B)
   	(A) edge node{$\epsilon$,c} (C)
   	(B) edge [bend left] node{a,c} (A)
   	(B) edge [loop right] node{c} (B)
   	(B) edge node{b} (C);
   	\end{tikzpicture}
   	\caption{Graphe du $\epsilon$-ANF de la table \ref{table:eanfdelta}}\label{fig:eanf}
   \end{figure}
\end{minipage}
\end{example}

Cette représentation a l'avantage d'être plus visuelle, alors que la table de transition est plus structurée.

% ███████  ██████ ██       ██████  ███████ ███████
% ██      ██      ██      ██    ██ ██      ██
% █████   ██      ██      ██    ██ ███████ █████
% ██      ██      ██      ██    ██      ██ ██
% ███████  ██████ ███████  ██████  ███████ ███████

\subsection{Algorithme ECLOSE}\label{adf:eclose}

L'algorithme ECLOSE concerne les $\epsilon$-ANFs. Il permet, à partir d'un état spécifique, de calculer l'ensemble des états atteignables uniquement par des transitions sur $\epsilon$. Ce calcul sert notemment au test d'appartenance d'un mot à un langage défini par un $\epsilon$-ANF comme présenté en \ref{adf:lang}.

Soit un $\epsilon$-ANF \automaton. Il est possible de construire un fonction retournant l'ensemble des états atteints uniquement en suivant des transitions sur $\epsilon$ pour un état $q$ donné. Cette fonction est la \emph{fermeture sur epsilon} $ECLOSE : Q \rightarrow 2^Q$. Sa définition est inductive.\\

Soit $q$ un état dans $Q$.\\
\textbf{Cas de base} $q$ est dans ECLOSE($q$)\\
\textbf{Pas de récurrence} Si $p$ est dans ECLOSE($q$) et qu'il existe un état $r$ tel quel $r\in\delta(p,\epsilon)$, alors $r$ est dans ECLOSE($q$).\\

ECLOSE peut être utilisé indifféremment sur un ensemble d'états S ($ECLOSE : 2^Q \rightarrow 2^Q$). Alors, $ECLOSE(S)=\bigcup_{q\in S}ECLOSE(q)$.

\begin{example}[ECLOSE]\label{ex:anfclosure} Considérons l'automate $A$ de l'exemple \ref{ex:anf}. Les différentes fermetures peuvent être calculées :
	\begin{itemize}
		\item ECLOSE($q_0$) = $\{q_0,q_1,q_2\}$. En effet, $q_0$ appartient à sa fermeture, selon le cas de base. Aussi, $q_1,q_2\in\delta(q_0, \epsilon)$.
		\item ECLOSE($q_1$)=$\{q_1\}$ par le cas de base.
		\item ECLOSE($q_2$)=$\{q_2\}$ par le cas de base.
	\end{itemize}
\end{example}



% ██       █████  ███    ██  ██████
% ██      ██   ██ ████   ██ ██
% ██      ███████ ██ ██  ██ ██   ███
% ██      ██   ██ ██  ██ ██ ██    ██
% ███████ ██   ██ ██   ████  ██████

\subsection{Langage d'un automate}\label{adf:lang}
Un automate représente un langage. Cette section explique comment il le fait pour les 3 catégories d'automates.

\subsubsection*{Fonction de transition étendue}

La \emph{fonction de transition étendue} $\hdelta$ est une extension de la fonction de transition, acceptant plusieurs symboles de façon consécutive. Intuitivement, il s'agit de suivre plusieurs arcs sur le graphe.

Comme $\delta$ est différente en fonction du type d'automate considéré, $\hdelta$ l'est aussi.

\begin{itemize}
  \item \textbf{ADF :} $\hdelta : Q \times \Sigma^* \rightarrow Q$. $\hdelta$ prend en entrée un état de $Q$ et un mot $w$ sur $\Sigma$ et retourne un état de $Q$.
  \item \textbf{ANF et $\epsilon$-ANF :} $\hdelta : Q \times \Sigma^* \rightarrow 2^Q$. $\hdelta$ prend en entrée un état de $Q$ et un mot $w$ sur $\Sigma$ et retourne un ensemble d'états de $Q$.
\end{itemize}

Soit un état $q \in Q$ et un mot $w \in \Sigma^*$. Alors $\hdelta$ est définie par:\\
\textbf{Cas de base} $w$ est un mot vide :
  \begin{itemize}
    \item Pour un ADF ou ANF : $\hdelta(q, \epsilon) = q$.
    \item Pour un $\epsilon$-ANF : $\hdelta(q, \epsilon) = ECLOSE(q)$.
  \end{itemize}
\textbf{Pas de récurrence} Si $|w|\ge 1$, alors $w=xa$ avec $x$ un mot sur $\Sigma$ et $a$ un symbole de $\Sigma$.
\begin{itemize}
  \item Pour un ADF ou ANF : $\hdelta(q,w) = \hdelta(q,xa)= \delta(\hdelta(q,x),a)$
  \item Pour un $\epsilon$-ANF : $\hdelta(q,w) = \hdelta(q,xa)= ECLOSE(\delta(\hdelta(q,x),a))$.
\end{itemize}
Dans le cas particulier où $|w|=1$, $w=xa=\epsilon a$, ce qui mène au cas de base.

Il se peut que la fonction de transition $\delta$ ne soit pas définie pour une paire d'arguments. Auquel cas, $\hdelta$ ne l'est pas non plus.\\

\subsubsection*{Chemin}

Un \emph{chemin} est une suite d'états d'un automate. Chaque état de cette suite doit être atteignable par une transition depuis l'état précédent dans cette suite.

\begin{example}[Chemin]
 Considérons l'automate $A$ de la figure \ref{fig:a1}. Il existe un chemin de $q_0$ à $q_5$ : $(q_0,q_2,q_5)$. En effet, les transitions sont définies : $\delta(q_0, a)=q_2$ et $\delta(q_2, b)=q_5$. Un mot représenté par ce chemin est $ab$.
\end{example}

Dans le cas où plusieurs transitions mènent d'un état à un autre, plusieurs mots peuvent être représentés par un même chemin.
Chaque état d'un chemin entre deux états $p$ et $q$ et distinct de ceux-ci est dit \emph{état intermédiaire}. S'il existe un chemin menant de $q_0$ à un état $p$, $p$ est dit \emph{atteignable}. Dans le cas contraire, il est \emph{inatteignable}.

\subsubsection*{Langage}
Le \emph{langage représenté} par un automate \automaton $L(A)$ peut alors se définir comme les mots qui, par l'application de $\hdelta$ sur l'état initial, donnent un état acceptant. Si deux automates représentent le même langage, ils sont dit \emph{équivalents}. Voici les définitions ensemblistes, respectivement pour un ADF et pour un $(\epsilon)$-ANF
$$
L(A)= \{w \in \Sigma^* | \hdelta(q_0,w) \in F\} \hspace{0.5cm}
L(A)= \{w \in \Sigma^* | \exists q \in \hdelta(q_0,w), q \in F\}
$$

Un mot appartenant à $L(A)$ est dit \emph{accepté} par l'automate $A$.


\begin{example}
  Soit $A$ l'ADF de la figure \ref{fig:a1}. Alors $abaa$ est un exemple de mot appartenant à $L(A)$. En effet :
  \begin{align*}
    &\hdelta(q_0,abaa)=\\
    &\delta(\hdelta(q_0,aba),a)=\\
    &\delta(\delta(\hdelta(q_0,ab),a),a)=\\
    &\delta(\delta(\delta(\hdelta(q_0,a),b),a),a)=\\
    &\delta(\delta(\delta(\delta(q_0,a),b),a),a)=\\
    &\delta(\delta(\delta(q_2,b),a),a)=\\
    &\delta(\delta(q_5,a),a)=\\
    &\delta(q_3,a)=\\
    &q_3 \in F
  \end{align*}
\end{example}

\begin{example}
  Soit $A$ le $\Sigma$-ANF de la figure \ref{fig:eanf}. Alors $cb$ est un exemple de mot appartenant à $L(A)$. En effet :
  \begin{align*}
    &\hdelta(q_0,cb)=\\
    &ECLOSE(\delta(\hdelta(q_0, c),b))=\\
    &ECLOSE(\delta(ECLOSE(\delta(\hdelta(q_0,\epsilon),c)),b))=\\
    &ECLOSE(\delta(ECLOSE(\delta(ECLOSE(q_0),c)),b))=\\
    &ECLOSE(\delta(ECLOSE(\delta(\{q_0,q_1,q_2\},c)),b))=\\
    &ECLOSE(\delta(ECLOSE(\{q_0,q_1,q_2\}),b))=\\
    &ECLOSE(\delta(\{q_0,q_1,q_2\},b))=\\
    &ECLOSE(\{q_1,q_2\})=\\
    &\{q_1,q_2\}
  \end{align*}
  On a bien l'ensemble d'états $\{q_1,q_2\}$ avec $q_2\in F$.
\end{example}

L'algorithme \ref{alg:membership_auto} représente cette appartenance pour un mot.


\begin{algo}[Appartenance d'un mot à un langage défini par un automate]\label{alg:membership_auto}
 \begin{algorithmic}[1]
   \REQUIRE un mot $w$, un automate \automaton représentant $L=L(A)$
   \ENSURE si $w$ appartient à $L$

   \STATE $C \leftarrow \{q_0\}$ \COMMENT{$C$ est l'ensemble des états courants}
   \IF {A est un $\epsilon$-ANF}
   \STATE $C \leftarrow ECLOSE(C)$
   \ENDIF
   \WHILE {$|w| > 0$}
   \STATE décomposer $w$ en $ax$ avec $a\in\Sigma$ et $x$ le reste du mot
   \STATE $C \leftarrow \delta(C,a)$ \COMMENT{passage à l'ensemble des états suivants}
   \STATE \COMMENT{Si l'automate est un ADF, C ne contient toujours qu'un seul état}
   \STATE $w \leftarrow x$
   \IF {A est un $\epsilon$-ANF}
   \STATE $C \leftarrow ECLOSE(C)$
   \ENDIF
   \ENDWHILE

   \RETURN s'il existe un état $q \in C$ appartenant à $F$
 \end{algorithmic}
\end{algo}

\begin{complexity}[Lecture d'un mot par un automate]

La complexité de l'algorithme \ref{alg:membership_auto} dépend du type d'automate considéré. Considérons que $|w|=n$.

L'opération 1 est en temps constant. Les opérations 2 à 4 ont la complexité d'ECLOSE. Pour un ADF ou ANF, cette opération est triviale ($\mathcal{O}(1)$). Pour un $\epsilon$-ANF, cette opération est en $\mathcal{O}(n)$. En effet, $n$ états au plus peuvent être ajoutés à l'ensemble.

Les opération 6 et 9 sont en temps constant. L'opération 7 à la complexité de $\delta$. Cette fonction est triviale pour un ADF. Si celui-ci est stocké dans un tableau, l'opéation est en temps constant. Pour un ANF ou $\epsilon$-ANF, comme $\delta$ porte sur un sous-ensemble de $Q$, l'opération est en $\mathcal{O}(n)$. Le pire des cas étant $C=Q$ avant ou après l'application de $\delta$. Les opérations 10 à 12 sont à nouveau une application de $ECLOSE$.

Dès lors, le pire des cas du corps de la boucle de l'opération 5 est le maximum entre le pire des cas de $ECLOSE$ et de $\delta$. Cette boucle s'effectue au plus $n$ fois. Une lettre est enlevée à chaque itération.

L'opération 14 se fait en $\mathcal{O}(\log_2(n))$ pour un ADF et $\mathcal{O}(n\log_2(n))$ pour un ANF ou $\epsilon$-ANF. Cette valeur suppose une recherche efficace dans F (en $\mathcal{O}(\log_2(n))$).

En conclusion :
\begin{table}[H]
  \centering
  \resizebox{\columnwidth}{!}{
  \begin{tabular}{|c|c|c|}
    \hline
    ADF & ANF & $\epsilon$-ANF\\
    \hline
    $\mathcal{O}(1)\!+\!n(\mathcal{O}(1)\!+\!\mathcal{O}(1))\!+\!\mathcal{O}(\log_2(n))$&$\mathcal{O}(1)\!+\!n(\mathcal{O}(1)\!+\!\mathcal{O}(n))\!+\!\mathcal{O}(nlog_2(n))$&$\mathcal{O}(n)\!+\!n(\mathcal{O}(n)\!+\!\mathcal{O}(n))\!+\!\mathcal{O}(n\log_2(n))$\\
    \hline
    $\mathcal{O}(n)$&$\mathcal{O}(n^2)$&$\mathcal{O}(n^2)$\\
    \hline
  \end{tabular}
  }
\end{table}



\end{complexity}




% ███████       ██     ██        █████
% ██           ██       ██      ██   ██
% █████       ██  █████  ██     ███████
% ██           ██       ██      ██   ██
% ███████       ██     ██       ██   ██

\subsection{Équivalence entre expression régulière et automate}\label{adf:eq}

Certains problèmes peuvent être exprimés sous forme d'appartenance à un langage régulier, et par extension à une expression régulière.
Pouvoir convertir une expression régulière en automate permet d'exécuter cet automate sur une machine pour tester l'appartenance. Ainsi, grâce à cette méthode, une grande classe de problèmes peut être résolue.


\begin{theorem}[ADF et expression régulière]
	Un langage peut être exprimé par un automate déterministe fini si et seulement si il peut être décrit par une expression régulière.
\end{theorem}

Ce théorème étant une double implication, il est vrai si les deux implications le sont. Étudions celles-ci séparemment.


\begin{theorem}[ADF $\implies$ expression régulière]
	Soit un langage $L$. Il existe un automate déterministe $A$ tel que $L(A)=L$ $\implies$ il existe une expression régulière $E$ telle que $L(E)=L$.
\end{theorem}
\begin{proof}
	Soit un langage $L$. Supposons qu'il existe un ADF \automaton tel que $L(A)=L$. $Q$ étant un ensemble fini, on peut définir sa cardinalité : $|Q|=n$. Supposons que ses états soient nommés $\{1,2,\dots,n\}$. Il est possible de construire des expressions régulières par induction sur le nombre d'états considérés. De plus, un tel automate est aisément représenté dans un ordre séquentiel, de gauche à droite. Ceci permet de séparer visuellement les $k$ premiers états du reste.

  Soient $i,j,k \in Q$, tous équivalents à des nombres inférieurs ou égaux à $n$. Définissons $E_{i,j}^k$ comme étant l'expression régulière décrivant un langage constitué des mots $w$ tels que $\hdelta(i,w)=j$ et qu'aucun état intermédiaire n'ait un nombre strictement supérieur à $k$.

	\begin{figure}[H]
		\centering
		\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm, semithick, bend angle=10]

		\tikzstyle{every state}=[circle]

		\node[initial,state] (A)                    {$1$};
		\node[state]         (B) [right of=A] {$2$};
		\node[state]         (C)  [right of=B] {$3$};
		\node[accepting, state]         (D)  [right of=C] {$4$};
		\node[state]         (E)  [right of=D]       {$5$};

		\path
		(A) edge [bend left=45] node{a} (C)
		(A) edge  node{b} (B)

		(B) edge [bend left=45] node{a} (A)
		(B) edge node{b} (C)

		(C) edge [bend left=45,dashed] node{a} (E)
		(C) edge [loop below] node{b} (C)

		(D) edge [loop below,dashed] node{a,b} (D)
		(E) edge [,dashed] node{a,b} (D)

		;
		\end{tikzpicture}
		\caption{Exemple : automate mettant $E_{1,3}^3$ en évidence. Les mots représentés par un chemin passant par un arc discontinu n'appartiennent par à $E_{1,3}^3$ : un des états intermédiaires est dénommé par un nombre supérieur à $k=3$.}\label{fig:proofeijk}
	\end{figure}


	L'exemple ci-dessus illustre ce fait qu'aucun état supérieur à $k$ ne peut faire partie des états intermédiaires. Intuitivement, il s'agit d'un automate auquel on a enlevé les transitions :
  \begin{itemize}
    \item Allant de $i$ à un nombre supérieur à $k$ (sauf $j$)
    \item Entre deux nombres supérieurs à $k$
    \item Allant d'un nombre supérieur à $k$ (sauf $i$) à $j$
  \end{itemize}
  En pratiques, celles-ci ne sont juste pas considérées lors de l'application de $\delta$.

	\paragraph{Cas de base} $k=0$. Comme tout état est numéroté $1$ ou plus, aucun intermédiaire n'est accepté.

  Une possibilité est $i \neq j$. Alors les chemins possibles ne se composent que d'un arc allant directement de $i$ à $j$. Pour les construire :

	Pour chaque paire $i$, $j$ :
	\begin{itemize}
		\item Il n'existe pas de symbole $a$ tel que $\delta(i,a)=j$. Alors, $E_{ij}^0=\emptyset$
		\item Il existe un unique symbole $a$ tel que  $\delta(i,a)=j$. Alors, $E_{ij}^0=a$
		\item Il existe des symboles $a_1,a_2,\dots,a_k$ tels que $\forall l \in \{1,\dots, k\}, \delta(i,a_l)=j$. Alors, $E_{ij}^0=a_1+a_2+\dots+a_k$
	\end{itemize}


  Une autre possibilité est $i=j$ et indique un chemin de longueur $0$. Auquel cas l'expression régulière représentant un chemin sans symbole est $\epsilon$. Ce chemin doit être ajouté au langage décrit par $E^k_{i,j}$ si $i=j$.


	\paragraph{Pas de récurrence} Supposons qu'il existe un chemin allant de $i$ à $j$ ne passant par aucun état ayant un numéro supérieur à $k$.	La première possibilité est que le-dit chemin ne passe pas par $k$. Alors, le mot représenté par ce chemin fait partie du langage de $E_{ij}^{k-1}$. Seconde possibilité, le chemin passe par $k$ une ou plusieurs fois comme représenté à la figure \ref{fig:ikjpath}.

	\begin{figure}[H]\centering
	\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm, semithick, bend angle=10]

	\tikzstyle{every state}=[circle]

	\node[state] (A) {$i$};
	\node[state] (B) [right of=A] {$k$};
	\node[state] (C) [right of=B] {$k$};
	\node[state] (D) [right of=C] {$k$};
	\node[state] (E) [right of=D] {$k$};
	\node[state] (F) [right of=E] {$j$};

	\path
	(A) edge [snake] (B)
	(B) edge [snake] (C)
	(C) edge [snake] (D)
	(D) edge [snake] (E)
	(E) edge [snake] (F)
	;

	\draw[-] (0.3,-0.8) arc (-100:-80:4.5) ;
	\draw[-] (2.24,-0.8) arc (-100:-80:16) ;
	\draw[-] (8.3,-0.8) arc (-100:-80:4.5) ;


	\node[draw=none] at (1.25,-1.4) {Dans $E_{ik}^{k-1}$};
	\node[draw=none] at (5.25,-1.4) {Mots dans $E_{kk}^{k-1}$};
	\node[draw=none] at (9.25,-1.4) {Dans $E_{kj}^{k-1}$};

	\end{tikzpicture}
	\caption{Un chemin de $i$ à $j$ peut être découpé en différent segment en fonction de $k$}\label{fig:ikjpath}
	\end{figure}

	Auquel cas, ces chemins sont composés d'un sous-chemin donnant un mot dans $E_{ik}^{k-1}$, suivi d'un sous-chemin donnant un ou plusieurs mots dans $E_{kk}^{k-1}$ et finalement un mot dans $E_{kj}^{k-1}$.

	En combinant les expressions des deux types, on obtient :
	$$
	E_{ij}^k = E_{ij}^{k-1}+E_{ik}^{k-1}(E_{kk}^{k-1})^*E_{kj}^{k-1}
	$$

	En commençant cette construction sur $E_{ij}^n$, comme l'appel se fait toujours à des chaînes plus courtes, éventuellement on retombe sur le cas de base. Si l'état initial est numéroté 1, alors l'expression régulière $E$ exprimant $L$ est l'union ($+$) des $E_{1j}^n$ tels que $j$ est un état acceptant.

	\hfill$\square$
\end{proof}
\stepcounter{algo}
\begin{complexity}
	Soit un ADF \automaton comportant $n$ états. Pour connaître la complexité totale de cet algorithme, il faut connaître le nombre total d'expressions régulières construites et la longueur de chacune de celles-ci.

	A chacune des $n$ itérations (ajoutant progressivement des nouveaux états admis pour état intermédiaire), la longueur de l'expression peut quadrupler : elle est exprimée par 4 facteurs. Ainsi, après $n$ étapes, cette expression peut être de taille $\mathcal{O}(4^n)$.

	Le nombre d'expressions à construire, lui, est décomposable en deux facteurs également : le nombre d'itérations et celui de paires $i,j$ possibles. Le premier facteur est $n$, quand aux paires, leur nombre s'exprime par $n^2$. $n^3$ expressions sont construites.

	En regroupant ces deux facteurs, on obtient $n^3\mathcal{O}(4^n)=\mathcal{O}(n^34^n)=\mathcal{O}(2^n)$. Comme $n$ correspond au nombre d'états, si la transformation se fait depuis un ANF, via un ADF, vers une expression régulière, la complexité devient doublement exponentielle. La première transformation étant elle-même exponentielle en le nombre d'états de l'ANF.
\end{complexity}


\begin{example}[Construction d'une expression régulière]
	Construction d'une expression régulière à partir de l'automate de la figure suivante :

	\begin{figure}[H]\centering
		\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm, semithick, bend angle=10]

		\tikzstyle{every state}=[circle]

		\node[initial,state] (A) {$1$};
		\node[accepting,state] (B) [right of=A] {$2$};

		\path
		(A) edge [bend left=20] node{0} (B)
		(B) edge [bend left=20] node{0} (A)

		(A) edge [loop above] node{1} (A)
		(B) edge [loop above] node{1} (B)
		;

		\end{tikzpicture}
		\caption{Un automate acceptant tout mot ayant un nombre impair de $0$}
	\end{figure}

	La construction par récurrence commençant avec $k=0$ le processus peut être représenté par des tableaux correspondant à différents $k$ de façon croissante.

	\paragraph{Première itération} Dans la première itération, chaque expression se résume à un des trois cas de base, avec éventuellement $\epsilon$ si $i=j$ pour l'expression analysée. Ici, $k=0$.

	\begin{figure}[H]
		\centering
		\begin{tabular}{|l|c|}
			\hline
			 & Cas de base\\
			\hline
			$E_{11}^0$& $1+\epsilon$\\
			$E_{12}^0$& $0$\\
			$E_{21}^0$& $0$\\
			$E_{22}^0$& $1+\epsilon$\\
			\hline
		\end{tabular}
	\end{figure}

	\paragraph{Seconde itération} Ensuite, l'état $1$ est autorisé comme état intermédiaire : $k=1$. Ayant potentiellement un état intermédiaire, la formule de récurrence est utilisée.

	\begin{figure}[H]
		\centering
		\begin{tabular}{|l|c|c|c|}
			\hline
			 & Formule de récurrence & Détail & Simplification\\
			\hline
			$E_{11}^1$& $E_{11}^0 + E_{11}^0(E_{11}^0)^*E_{11}^0$&
			$(1+\epsilon)+(1+\epsilon)(1+\epsilon)^*(1+\epsilon)$ & $1^*$\\
			$E_{12}^1$& $E_{12}^0 + E_{11}^0(E_{11}^0)^*E_{12}^0$&
			$0+(1+\epsilon)(1+\epsilon)^*0$ & $1^*0$ \\
			$E_{21}^1$& $E_{21}^0 + E_{21}^0(E_{11}^0)^*E_{11}^0$&
			$0+0(1+\epsilon)^*(1+\epsilon)$& $01^*$\\
			$E_{22}^1$& $E_{22}^0 + E_{21}^0(E_{11}^0)^*E_{12}^0$&
			$(1+\epsilon)+0(1+\epsilon)^*0$ & $\epsilon+1+01^*0$\\
			\hline
		\end{tabular}
	\end{figure}


	\paragraph{Troisième itération} A la troisième itération, l'état $2$ est autorisé comme état intermédiaire($k=2$).

	\begin{figure}[H]
    \centering
		\hspace{-5mm}\begin{tabular}{|l|c|c|}
			\hline
			 & Résultat\\
			\hline
			$E_{11}^2$&$1^*+1^*0(1+01^*0)^*01^*$\\
			$E_{12}^2$&$1^*0(1+01^*0)^*$\\
			$E_{21}^2$&$(1+01^*0)^*01^*$\\
			$E_{22}^2$&$(1+01^*0)^*$\\
			\hline
		\end{tabular}
	\end{figure}

	Pour obtenir une expression régulière correspondant à l'automate, on s'intéresse à celle qui décrit un chemin entre l'état initial ($1$) et les états acceptants (uniquement $2$ ici). Dès lors,  $E^2_{12}=1^*0(1+01^*0)^*=L$.

	Cette expression régulière $1^*0(1+01^*0)^*$ décrit bien un nombre impair de $0$. Il en faut absolument un, et tout ajout supplémentaire se fait par paire.

\end{example}



\begin{theorem}[Expression régulière $\implies$ ADF]
	($\Leftarrow$) Soit un langage $L$. Il existe une expression régulière $E$ telle que $L(E)=L$ $\implies$  il existe un automate déterministe $A$ tel que $L(A)=L$.
\end{theorem}


\begin{proof}
	Comme tout $\epsilon$-ANF a un ADF équivalent (théorème \ref{anf-dnf}), montrer qu'une expression régulière $E$ a un ANF équivalent est suffisant pour obtenir cet ADF.

	Soit un langage $L$. Soit $E$ une expression régulière telle que $L(E)=L$. On peut construire l'automate récursivement sur la définition des expressions régulières à la section \ref{ss:regex}. Cette preuve par récurrence repose sur trois invariants portant sur chaque ANF construit :
	\begin{enumerate}
		\item Il y a un unique état acceptant
		\item Aucune transition ne mène à l'état initial
		\item Aucune transition ne part de l'état acceptant
	\end{enumerate}
  Intuitivement, ces invariants servent à assurer que l'automate ainsi créé est lu de gauche à droite tel une expression régulière.

	\paragraph{Cas de base}	Les ANFs de la figure \ref{fig:regexadfbase} représentent les automates correspondant aux trois cas de base.

	\begin{figure}[H]

	\begin{subfigure}{.33\textwidth}\centering
		\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=4cm, semithick, bend angle=10,initial text= ]

		\tikzstyle{every state}=[circle]

		\node[initial,state,scale=0.5] (A) {};
		\node[accepting,state,scale=0.5] (B) [right of=A] {};

		\path
		(A) edge  node{$\epsilon$} (B)
		;
		\node[draw, fit=(A) (B)] {};

		\end{tikzpicture}
		\caption{$L=\{\epsilon\}$}
	\end{subfigure}
	\begin{subfigure}{.33\textwidth}\centering
		\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=4cm, semithick, bend angle=10,initial text= ]

		\tikzstyle{every state}=[circle]

		\node[initial,state,scale=0.5] (A) {};
		\node[accepting,state,scale=0.5] (B) [right of=A] {};

		\node[draw, fit=(A) (B)] {};

		\end{tikzpicture}
		\caption{$L=\emptyset$}
	\end{subfigure}
	\begin{subfigure}{.33\textwidth}\centering
		\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=4cm, semithick, bend angle=10,initial text= ]

		\tikzstyle{every state}=[circle]

		\node[initial,state,scale=0.5] (A) {};
		\node[accepting,state,scale=0.5] (B) [right of=A] {};

		\path
		(A) edge  node{$a$} (B)
		;
		\node[draw, fit=(A) (B)] {};

		\end{tikzpicture}
		\caption{$L=\{a\}$}
	\end{subfigure}

	\caption{Blocs de base pour la construction d'un automate à partir d'une expression régulière}
	\label{fig:regexadfbase}
	\end{figure}


	En effet, l'automate (a) représente le langage $\{\epsilon\}$ égal à $L(E)$ : le seul arc de l'état initial à un état final est $\epsilon$. L'automate (b) ne propose pas d'arc atteignant l'état final. Aucun mot n'appartient au langage représenté par cet automate qui vaut donc $\emptyset=L(\emptyset)$. Finalement, (c) propose un arc pour $a$. Dès lors, il existe un unique chemin de longueur 1 correspondant au mot $a$. Ainsi, le langage exprimé par cet automate $\{a\}$ est bien égal à $L(E)=L(a)$. De plus, ces automates respectent bien l'invariant de récurrence proposé.

	\paragraph{Pas de récurrence} Les ANF \emph{ abstraits} de la figure \ref{fig:regexadfrec} représentent la façon dont un automate peut être construit récursivement en fonction des règles de récurrence des expressions régulières. Ces ANF sont abstraits car le contenu d'un bloc $E$ ou $F$ n'est pas représenté explicitement. Cependant, celui-ci respecte les invariants de récurrence.

	\begin{figure}[H]

			\hspace{0.2\textwidth}\begin{subfigure}{.6\textwidth}\centering
				\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=4cm, semithick, bend angle=10,initial text= ]

				\tikzstyle{every state}=[circle]

				\node[initial,state,scale=0.5] (A) {};
				\node[state,scale=0.5] (B) [right of=A] {};
				\node[state,scale=0.5] (C) [right of=B] {};
				\node[accepting,state,scale=0.5] (D) [right of=C] {};

				\node[draw=none] (K) [right= 0.5cm of B] {$E$};

				\path
				(A) edge  node{$\epsilon$} (B)
				(C) edge  node{$\epsilon$} (D)

				(C) edge[bend right=90]  node{$\epsilon$} (B)
				(A) edge[bend right=40]  node{$\epsilon$} (D)

				;


				\node[draw, fit=(B) (C)] {};

				\end{tikzpicture}
				\caption{$L=L(E)^*$}
			\end{subfigure}\newline\vspace{1cm}


			\hspace{0.2\textwidth}\begin{subfigure}{.6\textwidth}\centering
				\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=4cm, semithick, bend angle=10,initial text= ]

				\tikzstyle{every state}=[circle]

				\node[initial,state,scale=0.5] (A) {};
				\node[state, scale=0.5] (B) [right of=A] {};
				\node[state, scale=0.5] (C) [right of=B] {};
				\node[accepting,state,scale=0.5] (D) [right of=C] {};


				\node[draw=none] (K) [right= 0.5cm of A] {$E$};
				\node[draw=none] (L) [right= 0.5cm of C] {$F$};

				\path
				(B) edge  node{$\epsilon$} (C)
				;


				\node[draw, fit=(A) (B)] {};
				\node[draw, fit=(C) (D)] {};



				\end{tikzpicture}
				\caption{$L=L(E)L(F)$}
			\end{subfigure}\newline\vspace{1cm}


			\hspace{0.2\textwidth}\begin{subfigure}{.6\textwidth}\centering
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=4cm, semithick, bend angle=10,initial text= ]

			\tikzstyle{every state}=[circle]

			\node[initial,state,scale=0.5] (A) {};

			\node[state,scale=0.5] (B) [above right of=A] {};
			\node[state,scale=0.5] (C) [below right of=A] {};

			\node[draw=none] (K) [right= 0.5cm of B] {$E$};
			\node[draw=none] (L) [right= 0.5cm of C] {$F$};

			\node[state,scale=0.5] (D) [right of=B] {};
			\node[state,scale=0.5] (E) [right of=C] {};

			\node[accepting,state,scale=0.5] (F) [below right of=D] {};

			\path
			(A) edge  node{$\epsilon$} (B)
			(A) edge  node{$\epsilon$} (C)

			(D) edge  node{$\epsilon$} (F)
			(E) edge  node{$\epsilon$} (F)
			;
			\node[draw, fit=(B)(D)] {};
			\node[draw, fit=(C)(E)] {};

			\end{tikzpicture}
			\caption{$L=L(E)+L(F)$}
		\end{subfigure}





		\caption{Enchaînement de blocs pour une construction récursive}
		\label{fig:regexadfrec}
	\end{figure}

	Les quatre règles de récurrence sur une expression régulière permettent de construire les automates:
	\begin{itemize}
    \item $L((E))=L(E)$ ne necéssite pas de construction supplémentaire.
    \item $L(E^*)=L(E)^*$ est construit comme en (a). En effet, l'arc revenant au début de $E$ permet d'exprimer $E^1$,$E^2$,$E^3$,...
    \item $L(EF)=L(E)L(F)$ est construit comme en (b). En effet, tout mot de cet automate est de la forme $v\epsilon w$ avec $v\in L(E)$ et $w\in L(F)$.
    \item $L(E+F)=L(E)\bigcup L(F)$ est construit comme en (c). En effet, tout mot de cet automate est de la forme $\epsilon v\epsilon$ ou $\epsilon w \epsilon$ avec $v\in L(E)$ et $w\in L(F)$, en accord avec la définition de l'union ensembliste.
	\end{itemize}

	Les automates (a), (b) et (c) respectent bien l'invariant de récurrence : pas de transition vers l'état initial, un seul état acceptant n'ayant pas de transition sortante. Chaque automate abstrait pour $E$ ou $F$ peut lui même être construit récursivement jusqu'au cas de base.

	\hfill$\square$
\end{proof}
\stepcounter{algo}
\begin{complexity}
	Soit une expression régulière $E$ contenant $n$ symboles (alphabet et opérations comprises) représentant un langage $L=L(E)$.
  La construction d'un ANF pour $L$ peut se faire en $\mathcal{O}(n)$. En effet :
	\begin{itemize}
		\item Cas de base : Au plus $n$ ANFs sont créés. Chacun correspond à un symbole (opérations non comprises). Chaque ANF a un état, rendant la création en temps constant. La création de tous ces ANFs est alors en $\mathcal{O}(n)$
		\item Récurrence : Il reste au plus $n$ symboles correspondant à des opérations, ce qui implique au plus $n$ opérations. Chaque opération se base sur les 4 règles de récurrences définies précédemment. Dans les cas necéssitant une construction, celle-ci peut se faire en temps constant (ajout d'au plus deux états et quatre transitions). Chaque opération n'est à effectuer qu'une seule fois, consommant le symbole, et que chacune se fait en temps constant. Dès lors, la totalité des étapes de récurrence se fait au plus en $\mathcal{O}(n)$
	\end{itemize}

	La complexité totale de cette conversion est en $\mathcal{O}(n)$ vers un ANF. La conversion vers un ADF, comme mentionné dans la section ci-après peut quand à elle être exponentielle.

\end{complexity}


%  █████  ██████  ███████       ██     ██        █████  ███    ██ ███████
% ██   ██ ██   ██ ██           ██       ██      ██   ██ ████   ██ ██
% ███████ ██   ██ █████       ██  █████  ██     ███████ ██ ██  ██ █████
% ██   ██ ██   ██ ██           ██       ██      ██   ██ ██  ██ ██ ██
% ██   ██ ██████  ██            ██     ██       ██   ██ ██   ████ ██


\subsection{Équivalence entre un ADF et un ANF}\label{adf:anfadf}
Il est possible de construire un ADF à partir d'un ANF et réciproquement, tous deux représentant le même langage $L$. Ici, ANF est considéré au sens-large et peut tout aussi bien être un ANF normal qu'un $\epsilon$-ANF. Ceci permet de justifier l'abstraction faite entre les différents types d'automates finis et l'utilisation du même terme pour tous ceux-ci.

Soit un ANF \automaton. Alors l'ADF équivalent
$$
D=(Q_D, \Sigma, \delta_D, q_D, F_D)
$$
est défini par :
\begin{itemize}
	\item $Q_D = \{T | T=\text{ECLOSE(}S\text{)} \text{ et } S \subseteq Q\}$. Concrètement, $Q_D$ est l'ensemble des parties des $Q$ fermées sur $\epsilon$. Ceci qui signifie que chaque transition sur $\epsilon$ depuis un état de $T$ mène à un état également dans $T$. L'ensemble $\emptyset$ est fermé sur $\epsilon$.
	\item $q_D$=ECLOSE($q_0$). L'état initial de $D$ est l'ensemble des états dans la fermeture sur $\epsilon$ des états de $A$.
	\item $F_D= \{T|T \in Q_D \text{ et } T \cap F \neq \emptyset\}$ contient les ensembles dont au moins un état est acceptant pour $A$.
	\item $\delta_D(T,a)$ est construit, $\forall a \in \Sigma, \forall T \in Q_D$ par :
		\begin{enumerate}
			\item Soit $T=\{p_1, p_2,\dots,p_k\}$.
			\item Calculer $\bigcup_{i=1}^k\delta(p_i,a)$. Renommer cet ensemble en $\{r_1, r_2, \dots, r_m\}$.
			\item Alors $\delta_D(T,a)=\bigcup_{j=1}^m\text{ECLOSE(}r_j\text{)}$.
		\end{enumerate}
\end{itemize}


\begin{example}[Transformation ANF vers ADF]\label{ex:anfadf} Considérons l'automate \automaton de l'exemple \ref{ex:anf} et les fermetures calculées dans l'exemple \ref{ex:anfclosure}.

Alors, l'automate $D=(Q_D, \Sigma, \delta_D, q_D, F_D)$ est donné par :

\begin{itemize}
	\item $Q_D=\{\emptyset, \{q_1\}, \{q_2\}, \{q_1,q_2\}, \{q_0,q_1,q_2\}\}$. Les ensembles $\{q_0,q_1\}$ et $\{q_0,q_2\}$ sont des sous-ensembles de $Q$ mais ne sont pas fermés sur $\epsilon$.
	\item $q_D=\{q_0,q_1,q_2\}=\text{ECLOSE(}q_0\text{)}$.
	\item $F_D=\{\{q_2\}, \{q_1,q_2\}, \{q_0,q_1,q_2\}\}$, les ensembles contenant $q_2$, étant acceptant de $A$.
	\item $\delta_D$ est exprimé sur le graphe de la figure \ref{fig:dndf}.
\end{itemize}


\begin{figure}[H]
	\centering
	\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=4cm, semithick, bend angle=10]

	\tikzstyle{every state}=[circle]

  \node[initial,state,accepting] (A) {$\{q_0,q_1,q_2\}$};
  \node[state,accepting] (B) [right of=A] {$\{q_0,q_1\}$};
  \node[state,accepting] (C) [right of=B] {$\{q_2\}$};
  \node[state] (D) [below of=B] {$\{q_1\}$};
  \node[state] (E) [below of=C] {$\emptyset$};


	\path
  (A) edge [loop above] node{a,c} (A)
  (A) edge [bend left] node{b} (B)

  (B) edge [bend left] node{a,c} (A)
  (B) edge node{b} (C)

  (C) edge node{a,b,c} (E)

  (D) edge node{a,c} (A)
  (D) edge node{b} (C)

  (E) edge [loop below] node{a,b,c} (E)
	;
	\end{tikzpicture}
  \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=4cm, semithick, bend angle=10]

	\tikzstyle{every state}=[circle]

  \node[initial,state,accepting] (A) {$A$};
  \node[state,accepting] (B) [right of=A] {$B$};
  \node[state,accepting] (C) [right of=B] {$C$};


	\path
  (A) edge [loop above] node{a,c} (A)
  (A) edge [bend left] node{b} (B)

  (B) edge [bend left] node{a,c} (A)
  (B) edge node{b} (C)
	;
	\end{tikzpicture}
	\caption{Automate $D$. De par la construction de $Q$, le nombre d'états de $D$ est exponentiel. Les états inatteignables et $\emptyset$ sont souvent omis pour clarifier la représentation.}\label{fig:dndf}
\end{figure}
\end{example}



\begin{theorem}[ANF $\Leftrightarrow$ ADF]\label{anf-dnf}
	Un langage $L$ peut être représenté par un ANF si et seulement si il peut l'être par un ADF.
\end{theorem}

\begin{proof}
	 Soit $L$ un langage. Cette preuve étant une double implication, chacune peut être prouvée séparément.

	($\Leftarrow$) $L$ peut être représenté par un ADF $\implies$ $L$ peut être représenté par un ANF. Supposons qu'un automate $D=(Q_D, \Sigma, \delta_D, q_D, F_D)$ représente $L$ : $L(D)=L$.
	L'ANF \automaton correspondant est construit comme suit :

	\begin{itemize}
		\item $Q=\{\{q\}|q\in Q_D\}\bigcup\emptyset$
		\item $\delta$ contient les transitions de $D$ modifiées. Les objets retournés deviennent des ensembles d'états. C'est-à-dire, si $\delta_D(q,a)=p$ alors $\delta(\{q\},a)=\{p\}$. De plus, pour chaque état $q\in Q_D$, $\delta(\{q\},\epsilon)=\emptyset$.
		\item $q_0=\{q_D\}$
		\item $F=\{\{q\}| q\in F_D\}$
	\end{itemize}

	 Dès lors, les transitions sont les mêmes entre $D$ et $A$, mais $A$ précise explicitement qu'il n'y a pas de transition sur $\epsilon$. Comme $A$ représente le même langage, il existe donc bien un ANF qui représente $L$.


	($\Rightarrow$) $L$ peut être représenté par un ANF $\implies$ $L$ peut être représenté par un ADF. Soit l'automate \automaton. Supposons qu'il représente $L=L(A)$. Considérons l'automate obtenu par la transformation détaillée à la section précédente (page \pageref{ex:anfadf}) :
	$$
	D=(Q_D, \Sigma, \delta_D, q_D, F_D)
	$$
	Montrons que $L(D)=L(A)$. Pour ce faire, montrons que les fonctions de transition étendues sont équivalentes. Auquel cas, les chemins sont équivalents et donc les langages sont égaux.
	Montrons que $\hdelta(q_0,w)=\hdelta_D(q_D,w)$ pour tout mot $w$, par récurrence sur $w$.

	\paragraph{Cas de base} Si $|w|=0$, alors $w=\epsilon$. $\hdelta(q_0,\epsilon)=$ ECLOSE($q_0$), par définition de la fonction de transition étendue. $q_D$=ECLOSE($q_0$) par la construction de $q_D$. Pour un ADF (ici, $D$), $\hdelta(p,\epsilon)=p$, pour tout état $p$. Par conséquent, $\hdelta_D(q_D,\epsilon)=q_D=\text{ECLOSE(}q_0\text{)}=\hdelta(q_0,\epsilon)$.

	\paragraph{Pas de récurrence} Supposons $w=xa$ avec $a$ le dernier symbole de $w$. Notre hypothèse de récurrence est que $\hdelta_D(q_D,x)=\hdelta(q_0,x)$. Ce sont bien les mêmes objets car $\hdelta_D$ retourne un état de $D$ qui correspond à un ensemble d'états de $A$. Notons celui-ci $\{p_1,p_2, \dots, p_k\}$. Par définition de $\hdelta$ pour un ANF, $\hdelta(q_0,w)$ est obtenu en :

	\begin{enumerate}
		\item Construisant $\{r_1,r_2,\dots, r_m\}=\bigcup_{i=1}^k \delta(p_i,a)$. Cet ensemble correspond aux états obtenus par la lecture du symbole $a$ à partir de $\{p_1,p_2,\dots,p_k\}$.
		\item Calculant $\hdelta(q_0,w)=\bigcup_{j=1}^m$ECLOSE($r_j$). Un état atteint par la lecture de $a$ l'est aussi par $a\epsilon$.
	\end{enumerate}

	$D$ a été construit avec ces deux mêmes étapes pour $\delta_D(\{p_1,p_2,\dots, p_k\},a)$. Dès lors, $\hdelta_D(q_D,w)=\delta_D(\{p_1,p_2,\dots, p_k\},a)=\bigcup_{j=1}^k$ECLOSE($p_j$)$=\hdelta(q_0,w)$.

	On a bien $\hdelta_D(q_D,w)=\hdelta(q_0,w)$.

  Les langages sont donc bien égaux.

	\hfill$\square$
\end{proof}

\stepcounter{algo}%TODO because we don't exactly have an algorithm here

\begin{complexity}[Conversion ANF vers ADF]

	La complexité d'une conversion ANF vers ADF peut être exprimée en fonction de $n$ le nombre d'états de l'ANF. La taille de l'alphabet $\Sigma$ est ici comptée comme une constante $k$. Elle est ignorée dans l'analyse grand-O. L'algorithme de conversion se fait en deux étapes. Le calcul de ECLOSE et la construction à proprement parler. Ici, l'automate est stocké sous forme d'une table de transitions. Cette solution est plus facile à manipuler mais peut engendrer un surcoût en mémoire, qui n'est pas analysé ici.

	\begin{itemize}
		\item ECLOSE : Chacun des $n$ états ayant une entrée pour $\epsilon$ dans la fonction $\delta$, le temps de calcul sur chaque nœud ajouté est en temps constant. Chacune des $n$ fermetures pour chacun des $n$ états $q \in Q$ pouvant au plus compter les $n$ états, le temps total de cette opération est en $n\mathcal{O}(n)=\mathcal{O}(n^2)$.

		\item Construction : Posons $s$ le nombre d'états dans l'ADF (qui, dans le pire des cas vaut $s=2^n$ par la construction des sous-ensembles). La création d'un état de l'ADF est en $\mathcal{O}(n)$. En effet, il faut garder des références vers les états de l'ANF concernés. Ceux-ci sont au plus $n$.

    Comme il y a $s$ états dans l'ADF, il y a $ks$ transitions. Chacune de celle-ci peut être construite en $\mathcal{O}(n)$. En effet, chaque état de l'ADF étant constitué d'au plus $n$ états de l'ANF, il y a au plus $n$ transitions à suivre pour obtenir l'ensemble d'états résultant dans l'ANF. Cet ensemble correspond alors à un état de l'ADF obtenu. Les transitions sont construites en $\mathcal{O}(nks)=\mathcal{O}(nks)$. $k$ est toujours considéré comme une constante.

	\end{itemize}

	La complexité dans le pire des cas est $\mathcal{O}(n^2) + \mathcal{O}(sn) + \mathcal{O}(sn) = \mathcal{O}(sn)=\mathcal{O}(n2^n)$.
	Le détail est donné sur $s$ car, comme prouvé dans \cite{Hopcroft00}, en pratique le nombre d'états dans l'ADF obtenu est rarement de l'ordre de $2^n$, typiquement de l'ordre de $n$. Dans ce cas là, la complexité devient $\mathcal{O}(n^2)$.

\end{complexity}


\begin{complexity}[Conversion ADF vers ANF]
	La conversion d'un ADF \automaton vers un ANF consiste au remplacement de $n$ états par $n$ ensembles d'un seul état. Chaque copie individuelle étant en temps constant, cette opération est en $\mathcal{O}(n)$.
  Ensuite, une nouvelle table de transition doit être créée. Si l'alphabet $\Sigma$ est de taille $k$, celle-ci a toujours $n$ lignes mais $k+1$ colonnes. En effet, un colonne est ajoutée pour $\epsilon$. La création de cette nouvelle table se fait alors en $\mathcal{O}(kn)$.
	La complexité totale d'une conversion d'un ADF vers un ANF est en $\mathcal{O}(kn)$.
\end{complexity}
