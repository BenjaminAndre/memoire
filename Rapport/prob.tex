Cette section décrit le problème rencontré par \cite{Vardhan04} et la technique générale utilisée pour proposer une solution à ce problème.

Les automates FIFO définis à la section \ref{sec:fifo} sont plus puissants que les ADF définis dans le chapitre \ref{ch:bases}. Contrairement, à ceux-ci, les automates FIFO ont possiblement une infinité d'états. Dans ces conditions, il n'est pas possible d'en faire une exploration exhaustive pour trouver tous les états acceptants.

À la place, une propriété dite de sécurité est définie. Si un état respecte cette propriété, il est sécure. Si il y a moyen de prouver que la totalité des états de l'automate respectent cette propriété, l'automate est considéré comme sécure. Si au contraire, un exemple de violation de la propriété est trouvé, l'automate peut être déclaré comme insécure.

Les sections suivantes donnent les différents éléments utilisés par \cite{Vardhan04} pour répondre à cette question. Un langage proxy est donné pour représenter les différents états d'un automate FIFO. Celui-ci est construit pour être régulier. De la sorte, il est possible d'appliquer l'algorithme d'Angluin pour apprendre ce langage proxy.

Celui-ci n'étant qu'une approximation du langage de l'automate FIFO, certaines incertitudes peuvent apparaître. Cependant, l'article justifie ces différents cas en ramenant la question à la sécurité, qui peut être répondue en un temps polynomial.

Dès lors, les différentes section permettent de construire ce langage, de se prononcer sur l'appartenance et l'équivalence avec ce langage et d'arrêter l'apprentissage s'il est possible de se prononcer sur la propriété de sécurité pour l'automate FIFO considéré.
