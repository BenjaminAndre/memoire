Cette section s'intéresse aux langages qui peuvent être associés à un automate. La section \ref{ss:trace} défini le langage de trace d'un automate. Celui-ci n'est pas nécessairement régulier. Les sections suivantes s'appuyent sur \cite{Vardhan04} pour proposer un langage régulier qui représente ce langage de trace.


% ██       █████  ███    ██  ██████
% ██      ██   ██ ████   ██ ██
% ██      ███████ ██ ██  ██ ██   ███
% ██      ██   ██ ██  ██ ██ ██    ██
% ███████ ██   ██ ██   ████  ██████

\subsection{Langage tracé}\label{ss:trace}

Une façon de définir un langage à partir d'un automate FIFO est de s'intéresser aux noms des transitions suivies lors de l'exécution. Cette section défini les éléments permettant d'arriver à la construction d'un tel langage.

Dans un système de transitions \tsys, la fonction de transition $\rightarrow:S\times\Theta\rightarrow S$ permet de définir le passage d'un état à un autre.

La \emph{fonction de transition étendue} $\xrightarrow{*}$ est la fermeture transitive et réflexive de $\rightarrow$.

Pour une suite de noms de transitions $\sigma=\theta_1\theta_2 ...\theta_n\in\Theta^*$, on note $(p,w)\xrightarrow{\sigma}(q,w')$ si il existe des états $(p_1,w_1)(p_2,w_2)...(p_{n-1},w_{n-1})$ tels que $(p,w)\xrightarrow{\theta_1}(p_1,w_1)\xrightarrow{\theta_2}...\xrightarrow{\theta_{n-1}}(p_{n-1},w_{n-1})\xrightarrow{\theta_n}(q,w')$. Dans ce cas, $\sigma$ est une \emph{trace de chemin}.

\begin{definition} Soit un automate FIFO $F$ et l'état initial $s_0=(q_0, \epsilon^C)$. Celui-ci est le couple état de contrôle initial $q_0$ ainsi que des mots $w[c]=\epsilon$ pour tout canal $c\in C$.

  Le \emph{langage de trace} d'un automate $F$ est

  $$
  L(F)=\{\sigma\in\Theta^*|\exists s=(p,w) \text{ tel quel } s_0\xrightarrow{\sigma}s\}
  $$
\end{definition}

\begin{example}
  Considérons l'automate FIFO $F$ de la figure \ref{fig:fifo1}.

  Pour celui-ci, $\sigma=\theta_1\theta_4\theta_7$ n'est pas un chemin. En effet,
  $$
  (q_0,[\epsilon,\epsilon])\xrightarrow{\theta_1}(q_1,[0,\epsilon])\xrightarrow{\theta_4}(q_3,[\epsilon,\epsilon])
  $$

  Mais, il n'existe pas d'état $s$ tel que $(q_3,[\epsilon,\epsilon])\xrightarrow{\theta_7}s$. En effet, pour appliquer cette transition, il aurait fallu que le canal $b$ contienne un symbole $0$. Ce n'est pas le cas.


  Par contre, $\sigma=\theta_2\theta_5\theta_5\theta_6\theta_7\theta_1\theta_4\theta_7$ est un chemin dans $F$ :
  \begin{equation*}
    \begin{gathered}
      (q_0,[\epsilon,\epsilon])\xrightarrow{\theta_2}
      (q_0,[1,\epsilon])\xrightarrow{\theta_5}
      (q_0,[1,0])\xrightarrow{\theta_5}
      (q_0,[1,00])\xrightarrow{\theta_6}
      (q_0,[\epsilon,00])\xrightarrow{\theta_7}\\
      (q_0,[\epsilon,0])\xrightarrow{\theta_1}
      (q_0,[0,0])\xrightarrow{\theta_4}
      (q_0,[\epsilon,0])\xrightarrow{\theta_7}
      (q_0,[\epsilon,\epsilon])
    \end{gathered}
  \end{equation*}

  On a bien un état $s$ (ici $s=(q_0,[\epsilon,\epsilon])=s_0$) tel que $s_0\xrightarrow{\sigma}s$.

\end{example}

  % ████████ ██   ██ ███████ ████████  █████
  %    ██    ██   ██ ██         ██    ██   ██
  %    ██    ███████ █████      ██    ███████
  %    ██    ██   ██ ██         ██    ██   ██
  %    ██    ██   ██ ███████    ██    ██   ██



\subsection{Alphabet d'annotation}

Le langage de trace n'est pas nécessairement régulier. Pour permettre l'apprentissage par l'algorithme d'Angluin, il faut en construire un qui est régulier et qui permette de reconstruire le langage de trace. Pour ce faire, ce nouveau langage devrait pouvoir représenter tout état atteignable ainsi qu'un ou plusieurs chemins ou mots témoins permettant d'atteindre ceux-ci.

Pour ce faire, pour chaque nom de transition correspondant à une action d'envoi, un \emph{co-nom} est défini :
$$
\bar{\Theta}=\{\bar{\theta}|\theta\in\Theta\wedge\exists p,q \in Q, c\in C, a\in\Sigma,\text{tels que } \delta(\theta)=(p,c!a,q)\}
$$

De plus, un \emph{symbole de contrôle} est créé pour chaque état de contrôle : $T_Q = \{t_q | q\in Q\}$.

En combinant les noms de transitions, les co-noms et les symboles de contrôlé, un nouvel alphabet peut-être défini, l'\emph{alphabet d'annotation} : $\Phi=(\Theta-\Theta_r)\bigcup\bar{\Theta}\bigcup T_Q$.

Avec $\Theta_r=\{\theta|\theta\in\Theta\wedge\exists p,q \in Q, c\in C, a\in\Sigma,\text{tels que } \delta(\theta)=(p,c?a,q)\}$, similaire à $\bar{\Theta}$ mais avec un nom pour chaque transition pour les actions de réception.


\subsection{Trace annotée}


Soit $\mathcal{A}:\Theta^*\rightarrow\Phi^*$ une fonction associant une \emph{trace annotée} à une trace d'automate. Soit une séquence de transitions $\sigma\in\Theta^*$. Pour chaque transition $\theta_{ri}\in\sigma$ associée à une action de réception,


\begin{algorithm}[H]
  	\begin{algorithmic}[1]
    \REQUIRE une suite de noms de transitions $\sigma\in\Theta^*$
		\ENSURE une trace annotée $\gamma\in\Phi^*$ représentant $\sigma$

    \STATE $\gamma\leftarrow\epsilon$
    \FORALL {transition $\theta\in\sigma$}
      \IF {$\theta$ correspond à une action de réception}
        \STATE trouver $\theta_s\in\Theta$ correspondant à une action d'envoi antécédant dans $\sigma$ tel que les actions s'appliquent sur le même canal et le même symbole
        \STATE remplacer $\theta_s$ par $\bar{\theta_s}\in\bar{\Theta}$
      \ELSIF {$\theta$ correspond à une action d'envoi}
        \STATE ah
      \ENDIF
    \ENDFOR

		\RETURN Vrai
	\end{algorithmic}
	\caption{$\mathcal{A}:\Theta^*\rightarrow\Phi^*$}\label{alg:A}
\end{algorithm}








Intuitivement, le \emph{langage de trace annotée} est composé d'éléments de \barTheta désignant des actions d'envoi qui n'ont plus d'impact (une action de réception pour le même symbole dans le même canal a eu lieu), suivie d'actions d'envoi impactant encore l'exécution de l'automate. Pour respecter la propriété attendue de donner un état et son témoin, le symbole de contrôle de l'état de contrôle obtenu par la liste de symboles est ajouté à la fin.
Séquence de transitions $l$ pas égal à $\sigma$ : sigma montre les états et est d'office valide !
Wait. Si $l\in L(F)$ mon argument s'évapore.
