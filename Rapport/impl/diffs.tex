Ce travail a rencontrés plusieurs difficultés. En voici la liste avec les contre-mesures proposées si c'est pertinent.

\begin{itemize}
  \item Les librairies utilisées sont complexes. Automatalib et Learnlib sont conçues de façon très générique. Cependant, ajouter le concept de file au automates n'était pas prévu. La solution apportée est de développer un pan dans chaque librairie dédié plus spécifiquement aux automates à files. Éventuellement, des méthodes ont été dupliquées dans ce contexte.
  \item La documentation était insuffisante ou introuvable. La documentation des librairies sur leur site respectif est succinte et sommaire. En général, le code n'est commenté que pour les classes n'ayant pas elles-même de super-classe. De plus, il manque des explications sur les relations entre les classes. Pour travailler dans ces conditions, il a fallu explorer une grande partie du projet, tester certaines fonctionnalités. Pour simplifier la lecture du code ajouté, des commentaires plus fréquent y ont été ajoutés. L'annexe \ref{app:mods} sert aussi de référence aux relations entre classes.
  \item Certaines opérations ne sont proposées que pour les ANF alors que l'algorithme d'Angluin est défini pour les ADFs. Une fonctionnalité a été ajoutée pour la traduction triviale d'un ANF à un ADF équivalent.
  \item Les librairies utilisent des dépendances complexes. Chaque librairie est découpée en de nombreux sous-modules interconnectés. Les cycles de dépendances sont interdits entre autres pour l'interprétation des annotations et la génération de code. La structure en sous-modules n'a pas été modifiée mais une attention particulière a été apportée aux dépendances et aux fichiers de configuration.
  \item L'article de Vardhan et al.\cite{Vardhan04} manque de précision sur l'implémentation de la méthode \emph{LeVer}. Entre autre en comparant des ensembles potentiellement infinis (les langages) sans expliquer comment c'est fait en pratique avec les automates. Des algorithmes ont dû être reconstruits pour permettre l'implémentation de ces opérations sur des ordinateurs. Parmis ceux-ci :
  \begin{itemize}
    \item L'algorithme d'appartenance de la section \ref{sec:app}.
    \item L'algorithme permettant de calcul de $\mathcal{F}(L)$ pour un langage de trace annotées $L$ donné, à la section \ref{sec:fl}
    \item L'algorithme permettant de comparer \fl et $L$ pour trouver un contre-exemple prouvant que $L$ n'est pas un point-fixe de \fl, à la section \ref{sec:fll}.
  \end{itemize}
  L'article ne détaille pas non plus d'algorithme permettant de calculer l'ensemble des configuration à risque $\mathcal{W}(L)$. Cet ensemble est plus facile à calculer si les langages réguliers décrivant les configurations à risques ne s'intéressent pas au contenu des canaux mais uniquement aux états traversés dans l'automate à file. C'est cette approche qui est utilisée dans ce travail.  
\end{itemize}

Une solution idéale à toutes ces difficultés demanderait une réécriture profonde des librairies ainsi qu'un grand travail de documentation. Cela améliorait grandement la qualité du code mais est au-delà des limites de ce travail.
