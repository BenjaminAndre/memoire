Cette section s'intéresse aux langages qui peuvent être associés à un automate. La section \ref{ss:trace} définit le langage de traces d'un automate. Celui-ci est rarement régulier. Les sections suivantes s'appuyent sur \cite{Vardhan04} pour proposer un langage simplifié, plus souvent régulier, qui représente ce langage de traces. Finalement, la section \ref{ss:extension} définit une fonction $\mathcal{F}$ qui étend une trace et explique en quoi cela aide à faciliter le processus d'apprentissage. \todo{changer formulation ou expliquer ce qu'on apprend}


% ██       █████  ███    ██  ██████
% ██      ██   ██ ████   ██ ██
% ██      ███████ ██ ██  ██ ██   ███
% ██      ██   ██ ██  ██ ██ ██    ██
% ███████ ██   ██ ██   ████  ██████

\subsection{Langage tracé}\label{ss:trace}

Une façon de définir un langage à partir d'un automate à files est de s'intéresser aux noms des transitions suivies lors de l'exécution. Cette section définit les éléments permettant d'arriver à la construction d'un tel langage.

Dans un système de transitions \tsys, la fonction de transition $\rightarrow:S\times\Theta\rightarrow S$ permet de définir le passage d'un état à un autre.

La \emph{fonction de transition étendue} $\xrightarrow{*}$ est la fermeture transitive et réflexive de $\rightarrow$.

Pour une suite de noms de transitions $\sigma=\theta_1\theta_2 ...\theta_n\in\Theta^*$, on note $(p,w)\xrightarrow{\sigma}(q,w')$ si il existe des états $(p_1,w_1),(p_2,w_2),...,(p_{n-1},w_{n-1})$ tels que $(p,w)\xrightarrow{\theta_1}(p_1,w_1)\xrightarrow{\theta_2}...\xrightarrow{\theta_{n-1}}(p_{n-1},w_{n-1})\xrightarrow{\theta_n}(q,w')$. Dans ce cas, $\sigma$ est une \emph{trace de chemin}.

\begin{definition} Soit un automate à files $F$ et l'état initial $s_0=(q_0, \epsilon^C)$. Celui-ci est le couple état de contrôle initial $q_0$ ainsi que des mots $w[c]=\epsilon$ pour tout canal $c\in C$.

  Le \emph{langage de traces} d'un automate $F$ est

  $$
  L(F)=\{\sigma\in\Theta^*|\exists s=(p,w) \text{ tel quel } s_0\xrightarrow{\sigma}s\}
  $$
\end{definition}

\begin{example}
  Considérons l'automate $F$ de la figure \ref{fig:fifo1}.

  Pour celui-ci, $\sigma=\theta_1\theta_4\theta_7$ n'est pas une trace. En effet, on a
  $$
  (q_0,[\epsilon,\epsilon])\xrightarrow{\theta_1}(q_1,[0,\epsilon])\xrightarrow{\theta_4}(q_3,[\epsilon,\epsilon])
  $$

  mais, il n'existe pas d'état $s$ tel que $(q_3,[\epsilon,\epsilon])\xrightarrow{\theta_7}s$. En effet, pour appliquer cette transition, il aurait fallu que le canal $b$ contienne un symbole $0$. Ce n'est pas le cas.

  Par contre, $\sigma=\theta_2\theta_5\theta_5\theta_6\theta_7\theta_1\theta_4\theta_7$ est une trace. En effet, on a :
  \begin{equation*}
    \begin{gathered}
      (q_0,[\epsilon,\epsilon])\xrightarrow{\theta_2}
      (q_0,[1,\epsilon])\xrightarrow{\theta_5}
      (q_0,[1,0])\xrightarrow{\theta_5}
      (q_0,[1,00])\xrightarrow{\theta_6}
      (q_0,[\epsilon,00])\xrightarrow{\theta_7}\\
      (q_0,[\epsilon,0])\xrightarrow{\theta_1}
      (q_0,[0,0])\xrightarrow{\theta_4}
      (q_0,[\epsilon,0])\xrightarrow{\theta_7}
      (q_0,[\epsilon,\epsilon])
    \end{gathered}
  \end{equation*}

  On a bien un état $s$ (ici $s=(q_0,[\epsilon,\epsilon])=s_0$) tel que $s_0\xrightarrow{\sigma}s$.

\end{example}


  % ████████ ██   ██ ███████ ████████  █████
  %    ██    ██   ██ ██         ██    ██   ██
  %    ██    ███████ █████      ██    ███████
  %    ██    ██   ██ ██         ██    ██   ██
  %    ██    ██   ██ ███████    ██    ██   ██



\subsection{Alphabet d'annotation}

Le langage de traces en tant que tel n'apporte pas de simplification à l'automate. C'est une autre façon d'écrire un chemin. Pour permettre l'apprentissage par l'algorithme d'Angluin, il faut en construire un nouveau langage, si possible régulier, qui permette de reconstruire le langage de trace. Pour ce faire, ce nouveau langage devrait pouvoir représenter tout état atteignable ainsi qu'un ou plusieurs chemins ou mots témoins permettant d'atteindre ceux-ci.

Pour ce faire, pour chaque nom de transition correspondant à une action d'envoi, un \emph{co-nom} est défini :
$$
\bar{\Theta}=\{\bar{\theta}|\theta\in\Theta\wedge\exists p,q \in Q, c\in C, a\in\Sigma,\text{tels que } \delta(\theta)=(p,c!a,q)\}
$$

De plus, un \emph{symbole de contrôle} est créé pour chaque état de contrôle : $T_Q = \{t_q | q\in Q\}$.

En combinant les noms de transitions, les co-noms et les symboles de contrôle, un nouvel alphabet peut être défini, l'\emph{alphabet d'annotation} : $\Phi=(\Theta-\Theta_r)\bigcup\bar{\Theta}\bigcup T_Q$. Dans cet alphabet, on a $\Theta_r=\{\theta|\theta\in\Theta\wedge\exists p,q \in Q, c\in C, a\in\Sigma,\text{tels que } \delta(\theta)=(p,c?a,q)\}$, similaire à $\bar{\Theta}$ mais avec un nom pour chaque transition pour les actions de réception.


\subsection{Trace annotée}


Soit $\mathcal{A}:L(F)\rightarrow\Phi^*$ une fonction associant une \emph{trace annotée} à une trace d'automate à file $F$. Cette fonction est décrite par l'algorithme \ref{alg:A}.

\begin{algorithm}[H]
  	\begin{algorithmic}[1]
    \REQUIRE un automate à files \fifo , une trace $\sigma\in L(F)^*$
		\ENSURE une trace annotée $\gamma\in\Phi^*$ représentant $\sigma$

    \STATE $\gamma\leftarrow\epsilon$
    \FORALL {nom de transition $\theta\in\sigma$}
      \IF {$\delta(\theta)$ est une action de réception}
        \STATE trouver $\theta_s\in\Theta$ correspondant à une action d'envoi antécédant dans $\sigma$ telle que les actions s'appliquent sur le même canal et le même symbole
        \STATE $\gamma\leftarrow$ $\gamma$ où $\theta_s$ est remplacé par $\bar{\theta_s}\in\bar{\Theta}$ \COMMENT {$\theta$ n'est pas ajouté à $\gamma$}
      \ELSIF {$\delta(\theta)$ est une action d'envoi}
        \STATE $\gamma\leftarrow\gamma\theta$
      \ENDIF
    \ENDFOR
    \STATE trouver $q$ l'état de contrôle tel que $s_O\xrightarrow{\sigma}s=(q,w)$ pour un certain $w\in(\Sigma^*)^c$
    \STATE $\gamma\leftarrow\gamma t_q$ avec $t_q\in T_Q$ le symbole de contrôle associé à $q$
		\RETURN $\gamma$
	\end{algorithmic}
	\caption{$\mathcal{A}:L(F)^*\rightarrow\Phi^*$}\label{alg:A}
\end{algorithm}

Soit $AL(F)=\{\mathcal{A}(\sigma)|\sigma \in L(F)\}$ le \emph{langage de traces annotées} de l'automate $F$. $AL(F)$ est un ensemble de traces annotées correspondant à des exécutions valides de l'automate $F$. Intuitivement, $AL(F)$ contient l'ensemble des états atteignables par $F$ ainsi que les traces annotées servant de témoins de cette atteignabilité.

Soit un mot $\gamma \in \Phi^*$. $\gamma$ est \emph{correctement formaté} si il finit par un symbole de $T_Q$ et aucune autre occurence d'un symbole de $T_Q$ n'apparaît dans le mot. Soit un langage arbitraire $L$. $L$ est \emph{correctement formaté} si tous les mots $\gamma\in L$ le sont.


\begin{example}
Soit l'automate $F$ représenté par la figure \ref{fig:fifoAB}. Soient les traces $\sigma_1=\theta_2\theta_8$ et $\sigma_2=\theta_1\theta_3\theta_5\theta_2$. Alors, les traces annotées de ces traces sont : $\mathcal{A}(\sigma_1)=\theta_2\theta_8t_{(q_1,q_B)}=\gamma_1$ et $\mathcal{A}(\sigma_2)=\bar{\theta_1}\bar{\theta_5}t_{(q_0,q_B)}=\gamma_2$.
Bien qu'elles soient toutes deux correctement formatées, $\gamma_1$ ne correspond à aucune exécution valide de $F$. Dès lors, $\gamma_1$ n'appartient pas au langage de traces annotées de $AL(F)$ contrairement à $\gamma_2$.

Soit le mot $\gamma_3=t_{q_0,q_A}\theta_2 t_{q_0,q_B} \in \Phi^*$. $\gamma_3$ n'est pas correctement formatée : il est impossible que cette trace annotée appartienne à $AL(F)$.
\end{example}


\subsection{Fonction d'extension de trace}\label{ss:extension}

Cette section définit \fl pour un langage arbitraire $L$ et démontre que $AL(F)$ en est un point fixe minimum. De la sorte, tout langage qui n'est pas un point fixe minimum de \fl ne peut pas être $AL(F)$. Si c'est le cas, la question d'équivalence est répondue : les langages ne sont pas égaux. Il reste alors à générer un contre-exemple.

La \emph{fonction d'extension} $Post(L)$ permet d'étendre une trace annotée $\gamma$ avec le symbole $\theta$. Si $\gamma$ est correctement formatée, $source(\theta)$ et $cible(\theta)$ donnent respectivement la source et la cible d'une transition $\delta$.

$$
Post(\gamma,\theta) = \left\{ \begin{array}{ll}
    \emptyset & \text{si } \gamma \text{ n'est pas correctement formaté ou si } \mathcal{C}(\gamma)\neq source(\theta)\\
    \{\mathcal{T}(\gamma)t_{cible(\theta)}\} & \text{sinon si }\delta(\theta)=(p,\tau,q) \text{ ou } \delta(\theta)=(p,c_i!a_j,q) \text{ avec }p,q\in Q\\
    \{deriv(\mathcal{T}(\gamma),\theta)t_{cible(\theta)}\}& \text{sinon si } \delta(\theta)=(p,c_i?a_j,q) \text{ avec }p,q\in Q \\
    \end{array} \right.
$$

Sachant que $deriv(\mathcal{T}(\gamma),\theta)$ fonctionne comme l'algorithme $\mathcal{A}$ si $\theta$ est une action de réception. Elle le fait en remplaçant un $\theta_e \in \Theta$ associé à une action d'envoi et le remplace par $\bar{\theta_e} \in \bar{\Theta}$ si l'action porte sur le même canal et le même symbole que $\theta$.

Posons $Post(\gamma)=\bigcup_{\theta\in\Theta}Post(\gamma,\theta)$ et $Post(L)=\bigcup_{\gamma\in L}Post(\gamma)$.


\begin{theorem}\label{thm:fl}
  Soit \fl$=Post(L)\cup\{t_{q0}\}$ où $q_0$ est l'état de contrôle initial. \fl est une opération monotone sur les ensemble c'est-à-dire qu'elle préserve l'inclusion d'ensembles. De plus, $AL(F)$ est le plus petit point fixe de \fl.
\end{theorem}

La preuve de ce théorème est disponible en annexe de \cite{Vardhan04}.

Le théorème \ref{thm:fl} donne bien une façon de répondre à la requête d'équivalence dans une direction. Alors, si $A\oplus B$ donne la différence symétrique entre deux ensembles (l'union à l'exception de leur intersection), le contre-exemple à l'équivalence se trouve dans $AL(F)\oplus L$.

\todo{reformuler et approprier}
Plusieurs cas sont possibles :
\begin{enumerate}
  \item \fl$-L\neq\emptyset$. Il existe un mot $w\in$\fl qui n'appartient pas à $L$.
  \begin{itemize}
    \item Si $w=t_{q_0}$, alors il appartient à $AL(F)\oplus L$
    \item Sinon, il faut vérifier si $w$ est correctement formaté.
      \begin{itemize}
          \item Si c'est le cas, alors $w\in(AL(F)\oplus L)$
          \item Sinon, c'est qu'il existe $w'\in L$ tel que $w\in Post(w')$ . $Post()$ d'une annotation valide retourne un annotation valide. Par contraposée, si $w$ est invalide, $w'$ l'est aussi. Dès lors, $w'\notin AL(F)$ et donc $w'\in(AL(F)\oplus L)$.
      \end{itemize}
  \end{itemize}
  \item \fl$\subsetneq L$. Si un \emph{point préfixe} est un ensemble $Z$ qui réduit par l'application de $\mathcal{F}$ ($\mathcal{F}(Z)\subseteq Z$), alors $L$ est un point préfixe.

   En appliquant $\mathcal{F}$ des deux côtés, ce qui préserve l'inclusion car $\mathcal{F}$ est monotone, on obtient $\mathcal{F}(\mathcal{F}(L))\subsetneq\mathcal{F}(L)$.

   Donc, $\mathcal{F}(L)$ est également un point préfixe. Soit $w$ un mot dans l'ensemble $L-\mathcal{F}(L)$. Comme $w$ n'est pas dans l'intersection de ces deux point préfixes, il ne fait pas partie du point fixe minimum $AL(F)$. En effet, selon la théorie des points fixes de Knaster-Tarski (annexe \ref{app:tarski}), un point fixe minimal est également l'intersection de tous les points préfixes de $\mathcal{F}$.

   Dès lors, $w\in AL(F)\oplus L$.
  \item \fl$=L$. Soit \wl l'ensemble des traces annotées menant à des états n'étant pas sûrs. \wl est défini et une formule est donnée pour le calculer dans la section \ref{sec:unsafe}.
  \begin{itemize}
    \item Si \wl est vide, comme $L$ est un point fixe (notre hypothèse pour ce point), le processus d'apprentissage peut être arrêté et la sécurité de l'automate est confirmée.
    \item Sinon, soit $\gamma$ un mot dans cet ensemble \wl. Si $\gamma$ est valide c'est-à-dire $\gamma\in AL(F)$, il peut être retourné comme contre-exemple à la sécurité de $F$. Si $\gamma$ est invalide, $\gamma\in(AL(F)\oplus L)$
  \end{itemize}
\end{enumerate}

Le langage $L$ n'est pas forcément $AL(F)$ dû à cette équivalence limitée (à un sens). Ce pourrait très bien être un autre point fixe contenant $AL(F)$ ou un autre ensemble contenant une trace annotée menant à un état qui n'est pas sûr. Cependant, ce n'est pas important tant que seule la propriété de sécurité est considérée.
