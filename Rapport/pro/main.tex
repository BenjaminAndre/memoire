La section \ref{sec:prob} définit plus clairement la problématique à l'aide des éléments du chapitre précédent. Elle explique comment les différentes sections de ce chapitre confluent vers une solution à la problématique en question.

Ensuite, la section \ref{sec:fifo} étend le concept des automates aux automates à files et définit une nouvelle opération. Une forme de langage sur ces nouveaux automates est proposée à la section \ref{sec:trace}.

Finalement, la notion de sûreté est définie dans la section \ref{sec:unsafe} avec une formule permettant de calculer les états concernés.

Tous ces éléments combinés permettent l'utilisation de LeVer, la technique proposée par \cite{Vardhan04} et d'en implémenter l'algorithme dans le chapitre \ref{ch:impl}.



Cette section décrit le problème rencontré par \cite{Vardhan04} et la technique générale utilisée pour proposer une solution à ce problème.

Les automates à files définis à la section \ref{sec:fifo} sont plus puissants que les ADF définis dans le chapitre \ref{ch:bases}. Contrairement à ceux-ci, les automates à files ont potentiellement une infinité d'états. Dans ces conditions, il n'est pas possible d'en faire une exploration exhaustive pour trouver tous les états acceptants.

À la place, une propriété dite de sécurité est définie. Si un état respecte cette propriété, il est \emph{sécurisé}. Si il y a moyen de prouver que la totalité des états de l'automate respectent cette propriété, l'automate est considéré comme sécurisé. Si au contraire, un exemple de violation de la propriété est trouvé, l'automate peut être déclaré comme à risque.

Les sections suivantes donnent les différents éléments utilisés par \cite{Vardhan04} pour répondre à cette question. Un nouveau langage est donné pour représenter les différents états d'un automate à files. Celui-ci est construit pour pouvoir être régulier pour certains automates. De la sorte, il est possible d'appliquer l'algorithme d'Angluin pour apprendre ce nouveau langage.

Celui-ci n'étant qu'une approximation du langage de l'automate à files, certaines incertitudes peuvent apparaître. Cependant, l'article justifie ces différents cas en ramenant la question à la sécurité, qui peut être répondue en un temps polynomial.

Dès lors, les différentes sections permettent de construire ce langage, de se prononcer sur l'appartenance et l'équivalence avec ce langage et d'arrêter l'apprentissage s'il est possible de se prononcer sur la propriété de sécurité pour l'automate à files considéré.


\section{Approche}\label{app}\input{pro/app}
\section{Langage de trace}\label{trace}\input{pro/trace}
\section{Appartenance}\label{mem}\input{pro/membership}
\section{Équivalence}\label{eq}\input{pro/equivalence}
\section{Sûreté}\label{safety}\input{pro/unsafe}
\section{Algorithme}\label{lever}\input{pro/lever}
